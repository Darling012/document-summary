##### 名词
1. JVM 内存结构
	1. 堆、本地方法栈、虚拟机栈、方法区
2. JMM 内存模型
	1. ava 内存模型，其实是保证了 Java 程序在各种平台下对内存的访问都能够得到一致效果的机制及规范。目的是解决由于多线程通过共享内存进行通信时，存在的原子性、可见性（缓存一致性）以及有序性问题。
	2. 除此之外，Java内存模型还提供了一系列原语，封装了底层实现后，供开发者直接使用。如我们常用的一些关键字：synchronized、volatile以及并发包等。
3. 堆内内存和堆外内存
	1. 



[38道JVM面试题](https://mp.weixin.qq.com/s/k43Zdw8DfHPekOAH1sdhTQ)

## CPU缓存

### CPU多级缓存  
左图为最简单的高速[缓存](缓存.md)的配置，数据的读取和存储都经过高速缓存，CPU核心与高速缓存有一条特殊的快速通道；主存与高速[缓存](缓存.md)都连在系统总线上（BUS）这条总线还用于其他组件的通信  
在高速缓存出现后不久，系统变得越来越复杂，高速[缓存](缓存.md)与主存之间的速度差异被拉大，直到加入了另一级缓存，新加入的这级缓存比第一缓存更大，并且更慢，而且经济上不合适，所以有了二级缓存，甚至是三级缓存。  
![cup缓存](https://upload-images.jianshu.io/upload_images/7220971-355d4c8c7f48e280.png)   ^lftr0e
  
* 为什么需要CPU cache？  
> CPU的频率太快了，快到主存跟不上，这样在处理器时钟周期内，CPU常常需要等待主存，浪费资源，  
所以cache的出现，是为了缓解CPU和内存之间速度的不匹配问题（结构：cpu->cache->memort）  
  
* CPU cache有什么意义？  
> 1. 时间局部性：如果某个数据被访问，那么在不久的将来他很可能被再次访问  
2. 空间局部性：如果某个数据被访问，那么与他相邻的数据很快也可能被访问  
  
* 缓存一致性（MESI）  
> M: Modified 修改，指的是该[缓存](缓存.md)行只被缓存在该CPU的缓存中，并且是被修改过的，因此他与主存中的数据是不一致的，  
      该缓存行中的数据需要在未来的某个时间点（允许其他CPU读取主存相应中的内容之前）写回主存，然后状态变成E（独享）  
  E：Exclusive 独享 缓存行只被缓存在该CPU的缓存中，是未被修改过的，与主存的数据是一致的，可以在任何时刻当有其他CPU读取该内存时，变成S（共享）状态，当CPU修改该缓存行的内容时，变成M（被修改）的状态  
  S：Share 共享，意味着该缓存行可能会被多个CPU进行缓存，并且该缓存中的数据与主存数据是一致的，当有一个CPU修改该缓存行时，其他CPU是可以被作废的，变成I (无效的)  
  I：Invalid 无效的，代表这个缓存是无效的，可能是有其他CPU修改了该缓存行  
  
## Java 内存模型 JMM

##### refrence  
  
1. [慕课网高并发实战（二）-并发基础](https://www.jianshu.com/p/7ac4383bf9a1)  
1. [一文带你读懂深入理解Java内存模型（面试必备）](https://mp.weixin.qq.com/s?__biz=MzU4Njc1MTU2Mw==&mid=2247483724&idx=1&sn=6a04d7a34e38d1b90f809be224dd5c65)  
2. [Java内存访问重排序的研究 - 美团技术团队](https://tech.meituan.com/2014/09/23/java-memory-reordering.html)


1. [求你了，再问你Java内存模型的时候别再给我讲堆栈方法区了](https://mp.weixin.qq.com/s?__biz=Mzg3MjA4MTExMw==&mid=2247485983&idx=1&sn=532f0e2a91e24592c985104d0657f5a4) 
2. [《深入理解 Java 内存模型》读书笔记](https://mp.weixin.qq.com/s?__biz=MzAxNjM2MTk0Ng==&mid=2247487954&idx=1&sn=d1a7109c41b924f1f6f63e8486bcf47a)
3. [Java Memory Model（JMM）](https://mp.weixin.qq.com/s?__biz=Mzg3MjA4MTExMw==&mid=2247485983&idx=1&sn=532f0e2a91e24592c985104d0657f5a4)
 

## jvm 内存结构
1. [Java内存图以及堆、栈、常量区、静态区、方法区的区别java静态变量存储在哪个区](https://blog.csdn.net/Marvel__Dead/article/details/69220153)
2. [JVM内存结构](https://mp.weixin.qq.com/s?__biz=Mzg3MjA4MTExMw==&mid=2247486219&idx=1&sn=ea4c9911fb726a0b0006244a26d49c32)
3. [JVM内存区域与内存分配](https://mp.weixin.qq.com/s?__biz=MzAxOTQxOTc5NQ==&mid=2650499934&idx=1&sn=1e09237b0e8a2ea9dbb57860db9ba8f1)
4. [Java 虚拟机内存](https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247486910&idx=1&sn=81053dfef5e17a42720c33baee002019)
5. [Java中基本类型和封装类型数据与堆、栈的关系_shanghaha的博客-CSDN博客](https://blog.csdn.net/shang02/article/details/51966939)
### Java 8 之后
[终于搞懂了Java 8 的内存结构，再也不纠结方法区和常量池了！！ - Java技术栈 - 博客园](https://www.cnblogs.com/javastack/p/15153856.html)
[JVM内存（堆和非堆）jdk1.8\_jvm 1.8 非堆内存设置\_qq\_道可道的博客-CSDN博客](https://blog.csdn.net/qq_16240085/article/details/106641569)
[深入理解堆外内存 Metaspace\_Javadoop](https://www.javadoop.com/post/metaspace)
## 堆内内存

### GC

《深入理解 Java 虚拟机》第 3 章 垃圾收集器与内存分配策略
##### GC
1. [Java垃圾回收：GC在什么时候对什么做了什么 - - ITeye博客](https://www.iteye.com/blog/chenzehe-1815717)
2. [详解JVM内存管理与垃圾回收机制1 - 内存管理](https://mp.weixin.qq.com/s/8hi3XyVhvspjO_Vp-qs-mg)
3. [Java 中 JVM 内存管理](https://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&mid=2247487556&idx=2&sn=174f51201a53679564d40ade1cc5cb1d)

[Java 垃圾回收](https://mp.weixin.qq.com/s/aA1eDYIUHuIfigTw2ffouw)
1. 什么是垃圾回收
2. 怎么定义垃圾
3. 怎么回收
##### 内存模型与回收策略
1. jvm 堆
	1. 年轻代
		1. 伊甸园区
		2. 幸存区
			1. from 区
			2. to 区
	2. 老年代
回收策略
1. 百分之九十八对象朝生夕死
2. 对象在年轻代进行分配
	1. 当年轻代没有足够空间，虚拟机会发起一次 Minor GC
	2. Minor GC 后，伊甸园区会被清空，不被回收的进入幸存者区的 from 区，若 from 区内存不够，则直接进入老年代
	3. 
3. 

[在 JVM 中如何判断一个对象的生死状态]( https://mp.weixin.qq.com/s?__biz=MzU0OTk3ODQ3Ng==&mid=2247485185&idx=1&sn=298d1a994b7bf791ddbad5c691a92a53 )
1. 引用计数器算法
	1. 主流 jvm 没有使用此算法的
	2. 优点：实现简单、性能高
	3. 缺点：增减计数器消耗性能及空间，无法解决循环引用
2. 可达性分析算法
	1. 核心思路是以 `GC roots` 对象为起点往下搜索，搜索路径称为 `引用链`， 当一个对象到 `GC roots` 没有 `引用链` 时即可回收。
	2. 可作为 GC roots 对象的列表
		1. 栈中的引用对象
		2. 本地方法栈中（即 native 方法）引用的对象
		3. 方法区中静态属性、常量的引用对象
3. 对象的引用
	1. 强引用
	2. 软引用
	3. 弱引用
	4. 虚引用
4. 对象真正死亡的两次标记
	1. ![](Pasted%20image%2020221026154525.png)


[图解 Java 垃圾回收机制]([图解 Java 垃圾回收机制，写得非常好！_zl1zl2zl3的博客-CSDN博客](https://blog.csdn.net/zl1zl2zl3/article/details/90904088))
##### 为什么需要分代就行垃圾收集
1. 逐一标记和压缩虚拟机内所有对象非常低效
2. 大部分对象，没多久后就不再被使用

新对象分配在新生代

## 堆外内存


[关于JVM堆外内存的一切 - 掘金](https://juejin.cn/post/6844903710766661639)
1. Java 中分配堆外内存的方式有两种
	1. 一是通过 `ByteBuffer.java#allocateDirect` 得到以一个 DirectByteBuffer 对象，其中DirectByteBuffer也是用Unsafe去实现内存分配的，对堆内存的分配、读写、回收都做了封装。
	2. 二是直接调用 `Unsafe.java#allocateMemory` 分配内存，但 Unsafe 只能在 JDK 的代码中调用，一般不会直接使用该方法分配内存。
2. 堆外内存的分配与回收
3. 堆外内存的使用场景
	1. 适合长期存在或能复用的场景
		1. 堆外内存分配回收也是有开销的，所以适合长期存在的对象
	2. 适合注重稳定的场景
		1. 堆外内存能有效避免因 GC 导致的暂停问题。
	3. 适合简单对象的存储
		1. 因为堆外内存只能存储字节数组，所以对于复杂的 DTO 对象，每次存储/读取都需要序列化/反序列化
	4. 适合注重 IO 效率的场景
		1. 用堆外内存读写文件性能更好
4. 堆外内存 IO 为什么有更好的性能
	1. 相对于 `DirectBuffer`，为什么 `HeapBuffer` 要多一次拷贝？
	2. [Java NIO direct buffer的优势在哪儿？ - 知乎](https://www.zhihu.com/question/60892134)


[10 双刃剑：合理管理 Netty 堆外内存](https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/Netty%20%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90%E4%B8%8E%20RPC%20%E5%AE%9E%E8%B7%B5-%E5%AE%8C/10%20%20%E5%8F%8C%E5%88%83%E5%89%91%EF%BC%9A%E5%90%88%E7%90%86%E7%AE%A1%E7%90%86%20Netty%20%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98.md)
1. 在 Java 中是不能直接使用 Unsafe 的，但是我们可以通过反射获取 Unsafe 实例
2. 


[https://mp.weixin.qq.com/s/WCkXBw-3e3xWBpNSPQl-7A](https://mp.weixin.qq.com/s/WCkXBw-3e3xWBpNSPQl-7A)

[从0到1起步-跟我进入堆外内存的奇妙世界 - 简书](https://www.jianshu.com/p/50be08b54bee)


[java 堆外内存 | lelouchcr's blog](https://caorong.github.io/2020/04/12/java-direct-memory/)
## Java 引用类型

[Java引用类型原理剖析](https://github.com/farmerjohngit/myblog/issues/10)