# 变量及配置
## 问题
1. java -jar 读取环境变量
2. `bootstrap.yml,application.yml`读环境变量
3. ![|300](Pasted%20image%2020230303163246.png)
4. 存在多份环境变量时的优先级

## 背景
1. k12 学生桌上的摄像头，跨机器，不确定能否通过域名访问，假如可以，只能是将域名绑定到路由器。不可以就只能写 kms 服务器的固定 IP。
2. k12 中 keycloak 中间件，老师登录管理端时浏览器会重定向到 keycloak 的服务器，所以要保证整个子网可用。配域名就得是校级路由器。
3. ftp 同 keycloak 情况，登录机器需要能访问到 ftp 服务。
4. mysql 、redis、mq 以及各个业务微服务，当前都位于单机中，用 docker-compose 启动。

<span style="background:#FFB78B">也就存在以下几种情况</span>：
1. 部署于同一台机器的各个 service 和 mysql 、redis、mq 需要通信，即单机内部通信。
2. 摄像头与 kms，用户访问 keycloak、ftp 等跨机器访问。

<span style="background:#FFB78B">总结</span>：
要想每次部署新机器不需要改 IP，也就是 IP 要是变量。变量就有两种：
1. 由外向内传入硬编码
	1. 每个文件手动写死，每次都改
	2. 自动化编译
		1. 单机：docker-compose 的 `.env`
		2. 多机：helm 或者 jenkins 有没有能改变 docker-compse 文件的方式
2. 由内向外读取环境变量
	1. 单机
		1. 系统变量
		2. docker 环境变量（考虑跨 docker-compose 能否读取到情况）
		3. `env_file`文件
	2. 多机
		1. docker-swarm 的 config 文件
		2. IP 的话可以在整个子网路由器配置域名


## 分析

==变量类型==
1. 静态的配置文件，编译过程替换掉成固定的。
	1. 此种情况使用于生成文件，命令。也就是在运行时应该是常量、应该是固定的。
	2. 会构建配置文件场景
		1. mvn构建jar编译时，将 yaml 替换为 pom 里的值。
		2. docker-compose 编译时将 docker-compose 文件里的`${}`替换为 `.env` 里的值。

2. 动态的环境变量，运行时读取。
	1. 会一层层往外找，要确认哪些变量会向哪些配置里找
		1. 会读取环境变量的
			1. 
		2. 域名转 IP 这种
			1. docker network 提供 当前 docker 网络内可通过域名连接
			2. 网络的DNS

==变量层级==
最大公约数原则，不然读不到。
1. 整个服务可用
	1. 子网内，ip域名
2. 整个服务端机器集群
	1. k8s、docker-swarm
3. 单机节点
	1. [系统环境变量](https://blog.csdn.net/jason_cuijiahui/article/details/79408778)
4. 单机微服务集群docker-compose
	1. 多个docker-compose：`env_file`文件（运行时读取）
	2. 单个docker-compose：`.env` 文件（编译时替换）

`.env`是用于替换docker-compose文件中的`${}`，本质是修改yaml配置文件。
`env_file`是提取docker-compose文件中的`environment`块，本质还是运行时的环境变量。


`docker-compose.yml` 的 `environment` 块中变量
	1. `JAVA_OPTS`覆盖`dockerfile`中的`ENV`，被`dockerfile`的`ENTRYPOINT`语句使用
	2. `env_profile`和`nacos`提供给`bootstrap.yml`使用的。
		1. `bootstrap.yml`的变量某些在mvn构建时会被替换
			1. mvn替换变量来源`pom.xml`的`properties`
			2. 命令行传入，如手动输入或`jenkinsfile`传入。
		2. `bootstrap.yml` 也会读取环境变量

要 `关注点分离`，分开考虑，每层往上，比如 `docker-compose.yml` 的变量可以从哪里读，就不要想 `dockerfile` 或者 `bootstrap.yml` 的变量值是怎么来的了，容易乱。因为只有两种情况：
1. 要么是由外向里传入后编译硬编码
2. 要么就是由内向外读取环境变量


## 总结
##### 硬编码
1. 直接 docker-compose 写死，每次改
2. `.env` 编译后等同硬编码
	1. `.env` 文件由于只作用于同文件夹下 docker-compose ，是编译型替换
##### 环境变量
1. 单机
	1. 系统环境变量
	2. 多个 docker-compose跨文件夹 `env_file`
	3. 单个 `environment` 块
2. 多机
	1. docker-swarm 的 config 文件
	

## 案例
==编译过程中替换的配置文件==
1. jar 启动所必须配置，本地 bootstrap.yml,application.yml, 远端 nacos 上配置, 外部环境变量
2. 单个服务，如服务名端口等配置由每个模块 pom 定义，后编译进 yaml
3. mvn 命令传递进 pom 的参数
4. jenkinsFile 传递进 mvn 命令的参数
5. jenkinsFile 传递进 dockerFile 的参数
6. dockerFile 传递进 java - jar 的参数

1. jenkinsFile
   1. CI
      1. 镜像 dockerFile
      2. jar    pom.xml  yaml   [maven读取环境变量](https://blog.csdn.net/fuck487/article/details/75104765)
   2. CD
      1. dockerCompose
      2. helm
==运行时读取环境变量==
1. 环境变量，mvn、jar、docker 运行时都可读取，dockerCompose 可提供，nacos 中的 yaml 也可以用
2. 命令行传入的
3. 各个文件定义的

### 优先级
应该尽量放在最外部，只有不通用的才放在尽可能高的层


[Docker变量](Docker变量.md)
## reference
1. [docker-compose中env\_file所定义的环境变量-CSDN博客](https://blog.csdn.net/kakaweb/article/details/123071435)


