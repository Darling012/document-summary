[什么是“堆”,"栈","堆栈","队列",它们的区别 - GuoXY - 博客园](https://www.cnblogs.com/guoxiaoyan/p/8664150.html)
[cs.usfca.edu/\~galles/visualization/algorithms.html](http://cs.usfca.edu/~galles/visualization/algorithms.html)
## DS
### 树


[树,二叉树,平衡二叉树,红黑树,B树等逐步深入了解   -  叶落山城秋](https://www.iphpt.com/detail/136)

#### 红黑树
[说说红黑树——不谈操作，只讲理解 - 特务依昂 - 博客园](https://www.cnblogs.com/tuyang1129/p/12556519.html)
1. 红黑树是为了解决AVL树频繁的旋转，不追求绝对的平衡，实现近似的平衡。
2. 在平衡和效率中折中，依靠它的五条约束实现。
3. 五条约束是数学推导出的结论，是他人研究的最终产物罢了，而红黑树仅仅是在使用这些结论。
[通俗易懂的红黑树图解(上)](https://mp.weixin.qq.com/s?__biz=Mzg3NTcwMTUzNA==&mid=2247486231&idx=1&sn=5f860b8bd38b85dd905c3d4e7cc5ba46)

[面试问到红黑树， B 树这种原理性的问题，怎么回答比较好?不啰嗦，又能回答到点子上 - V2EX](https://www.v2ex.com/t/769849)
无论红黑还是 B 树, 都是用来解决搜索问题的, 搜索越快越好嘛.  
其实最初的, 就是二叉搜索树. 如果这颗树比较平衡的话, 其搜索效率就等同于二分查找了.  
但是呢? 现实是, 二叉搜索树不平衡, 如果不平衡, 你想想, 搜索效率就很差了.  
所以呢? 能不能构建二叉搜索树时能让它尽量平衡一些?  
于是就有了平衡二叉搜索树.  
但是呢, 平衡二叉搜索树插入删除比较麻烦. 为了这种平衡, 付出代价太大(如果你就创建一次, 不经常变动也没事, 反正只有变动时才有代价)  
为了即要平衡, 又不想付出太大代价, 就有了红黑树了  
当然, 红黑树消除了插入删除的代价, 所以, 对于 HashMap 的某一个 bucket, 如果元素很多, 使用红黑树是很适合了.(因为 HashMap 一般经常要删除和修改)  
到了这里, 红黑树还是二叉树, 层还是比较深的, 和搜索的过程是和层的深度是有关的, 每一次要到某一层的节点加载到内存来比较.  
如果所有数据都在内存没问题, 但数据要是在磁盘呢? 每加载一次就是从磁盘到内存的一次 IO, 你也知道, 磁盘读写是很慢的. 所以能不能尽量减少这种 IO 呢?  
B 树就可以了, B 树不是二叉树, B 树是一种多叉搜索树, 每一个节点都有多个元素.  
这样, 对于全部节点固定情况下, B 树肯定比红黑树要浅了, 这样, 潜在的最大 IO 次数一定少了啊.  
所以 B 树就应用在数据库的场景下.  
同理, 如果你的搜索涉及到多种速度不一的存储介质, 也是可以考虑 B 树的。

#### B+树
[MySQL为什么要用B+树做索引](https://mp.weixin.qq.com/s/muOwXKNTvPjXjrLsFRveIw)
1. 为什么选树结构？
2. 为什么用B+树？

## algorithm

[10 大排序算法总结](https://github.com/francistao/LearningNotes/blob/master/Part3/Algorithm/Sort/%E9%9D%A2%E8%AF%95%E4%B8%AD%E7%9A%84%2010%20%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.md)


## 《大话数据结构》
数据结构
1. 逻辑结构
	1. 集合结构
	2. 线性结构
	3. 树形结构
	4. 图形结构
2. 物理结构
	1. 顺序存储
	2. 链式存储
### 第1章 数据结构绪论

### 第2章　算法

### 第3章　线性表

### 第4章　栈与队列

### 第5章　串

### 第6章　树
#### 6.1O线索二叉树

### 第7章　图

### 第8章　查找

### 第9章　排序

## 《漫画算法》
### 第1章 算法概述
##### 1.1.3 什么是数据结构
数据结构
1. 线性结构
	1. 数组
	2. 链表
	3. 以及衍生的栈、队列、哈希表等
2. 树
3. 图
4. 基本数据结构演变的
	1. 跳表
	2. 哈希链表
	3. 位图等


#### 1.2 时间复杂度

### 第2章数据结构基础
#### 2.1 什么是数组
有限个相同类型的变量所组成的有序集合，在内存中顺序存储，可以很好的实现顺序表。
#### 2.2 什么是链表
在物理上非连续、非顺序的随机存储的数据结构。
#### 2.3 物理结构和逻辑结构
物理结构
1. 顺序存储结构
	1. 数组
2. 链式存储结构
	1. 链表
逻辑结构
1. 线性结构
	1. 顺序表
	2. 栈
	3. 队列
2. 非线性结构
	1. 树
	2. 图
##### 2.3.2 什么是栈
先入后出
##### 2.3.4 什么是队列
先入先出
#### 2.4 什么是散列表

### 第3章树
#### 3.1什么是树和二叉树
##### 3.1.1什么是树
有许多逻辑关系并不是简单的线性关系，在实际场景中，常常存在着一对 多，甚至是多对多的情况。其中树和图就是典型的非线性数据结构。

##### 3.1.2什么是二叉树
这种树的每个节点最多有两个孩子节点。

###### 满二叉树
一个二叉树的所有非叶子节点都存在左右孩子，并且所有孩子都在同一层级上。
###### 完全二叉树
这个树的节点编号能跟同样深度的满二叉树编号一致，那么就是完全二叉树。

#### 3.2 二叉树的遍历
#### 3.3什么是二叉堆
##### 3.3.1什么是二叉堆
本质上是一种完全二叉树，分为两个类型
1. 最大堆
	1. 父节点的值大于或等于孩子节点
2. 最小堆
	1. 父节点的值小于或等于孩子节点
##### 3.3.2 怎么构建二叉堆
二叉堆的自我调整
##### 3.3.3 二叉堆的代码实现
二叉堆虽然是完全二叉树，但是存储方式并不是链式存储，而是顺序存储，即用数组。
#### 3.4 什么是优先队列
1. 最大优先队列
	1. 无论入队顺序如何，最大元素都优先出队，基于最大堆实现
2. 最小优先队列
	1. 
### 第4章 排序算法
#### 4.2 什么是冒泡排序
##### 思想
我们要把相邻的元素两两比较，当一个元素大于右侧相邻元素时，交换它们的位置；当一个元素小于或等于右侧相邻元素时，位置不变。
这样就把第一个最大的值放到了最右边，然后从头再开始一遍，把第二大、第三大的往右排。平均时间复杂度 是O（n2）。
双层for循环，内层对比大小调换位置。
##### 优化
1. 即设置标志位true，在内循环中改为false，然后再外循环判断标志位为true就跳出外循环。
	1. 也就是当元素没有换位置，也就说明了数组已经已经是有序的了，就不用外循环没对比的元素了。
	2. 也就是优化了某个位置元素对比后，它之前的元素已经是有序的情况
2. 还有种情况是后边几个元素对于整个数组来说已经是有序的。但内循环还是会对比这些元素。
	1. 所以再引入一个最后交换位置下标记录，控制内循环的数组对比长度
	2. 比如 `[3, 4, 2, 1, 5, 6, 7, 8]`
		1. 3和4，4不变，
		2. 4和2，4往后挪
		3. 4和1，4往后挪，下标为3
		4. 4和5、6、7、8，都不换，`[3,  2, 1, 4, 5, 6, 7, 8]` 也就是光对比前三个就行
##### 鸡尾酒排序
代码外层的大循环控制着所有排序回合，大循环内包含2个小循环，第1个小循环从左向右比较并交换元素，第2个小循环从右向左比较并 交换元素。

#### 4.3 什么是快速排序
冒泡排序在每一轮中只把1个元素冒泡到数列的一端，而快速排序则在每一轮挑选一个基准元素，并让其他比它大的元素移动到数列一边，比它小的元素移动到 数列的另一边，从而把数列拆解成两个部分。

##### 4.3.3 元素的交换
1. 双边循环法
2. 单边循环法
##### 4.3.5 非递归实现
#### 4.5 计数排序和桶排序

##### 4.5.2 初识计数排序
适用于无序随机整数排序，且受限于随机整数的取值范围，比如0-10，一共11个数，就建立个长度为11的数组，然后遍历无序的数组，比如无序数组第一个数是9，就在新建数组下标为9的位置上计数1，这样将无序数组内的值映射为新数组的下标，且记录了出现的次数。这样输出新数组，下标为几就输出几，值是几就输出几次。就把无序的数组转换输出成有序的了。
##### 4.5.3 计数排序的优化
即不再以取值范围直接作为数组长度，而是用取值范围的最大最小差+1做长度，再用值与最小值的差做偏移量。
###### 怎么对成绩排序？
即值有了意义，两个95分如何区分小明还是小红？

### 第6章 算法的实际应用

#### 6.3 LRU算法的应用
LRU全称Least Recently Used，也就是最近最少使用的意思，是一种内存管理算法，这个算法基于一种假设：长期不被使用的数据，在未来被用到的概率也不大。


## 《漫画算法2》

### 第1章 排序算法进阶
之前我讲解过冒泡排序、快速排序、堆排序、计数排序、桶排序。这一次：选择排序、插入排序、希尔排序、归并排序、基数排序。

### 第4章 查找算法
#### 4.2 什么是二分查找

#### 4.3 什么是跳表

## 《算法图解》



## [《数据结构与算法之美》](https://silenceallat.top/code/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E.html)
#### 25 | 红黑树（上）：为什么工程中都用红黑树这种二叉树？
##### 什么是平衡二叉查找树

## 《玩转数据结构》

## 《重学数据结构与算法》
#### [01 复杂度：如何衡量程序运行的效率？](http://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e9%87%8d%e5%ad%a6%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e7%ae%97%e6%b3%95-%e5%ae%8c/01%20%20%e5%a4%8d%e6%9d%82%e5%ba%a6%ef%bc%9a%e5%a6%82%e4%bd%95%e8%a1%a1%e9%87%8f%e7%a8%8b%e5%ba%8f%e8%bf%90%e8%a1%8c%e7%9a%84%e6%95%88%e7%8e%87%ef%bc%9f.md)




## [♥数据结构基础知识体系详解♥ | Java 全栈知识体系](https://pdai.tech/md/algorithm/alg-basic-overview.html)
树
1. 二叉树
	1. 斜树
	2. 满二叉树
	3. 全二叉树
2. 动态查找树
	1. 二叉查找树
	2. 平衡二叉树
	3. 红黑树
	4. 哈夫曼树
3. 多路查找树
	1. B-树（就是B树）
	2. B+ 树
	3. B* 树
	4. R 树

1.  `数组` 的下标寻址十分迅速，但计算机的内存是有限的，故数组的长度也是有限的，实际应用当中的数据往往十分庞大；而且无序数组的查找最坏情况需要遍历整个数组；后来人们提出了二分查找，二分查找要求数组的构造一定有序，二分法查找解决了普通数组查找复杂度过高的问题。任何一种数组无法解决的问题就是插入、删除操作比较复杂，因此，在一个增删查改比较频繁的数据结构中，数组不会被优先考虑
2. `普通链表` 由于它的结构特点被证明根本不适合进行查找
3. `哈希表` 是数组和链表的折中，同时它的设计依赖散列函数的设计，数组不能无限长、链表也不适合查找，所以也不适合大规模的查找
4. `二叉查找树` 因为可能退化成链表，同样不适合进行查找
5. `AVL树` 是为了解决可能退化成链表问题，但是AVL树的旋转过程非常麻烦，因此插入和删除很慢，也就是构建AVL树比较麻烦
6. `红黑树` 是平衡二叉树和AVL树的折中，因此是比较合适的。集合类中的Map、关联数组具有较高的查询效率，它们的底层实现就是红黑树。
7. `多路查找树` 是大规模数据存储中，实现索引查询这样一个实际背景下，树节点存储的元素数量是有限的 (如果元素数量非常多的话，查找就退化成节点内部的线性查找了)，这样导致二叉查找树结构由于树的深度过大而造成磁盘I/O读写过于频繁，进而导致查询效率低下。
8. `B树` 与自平衡二叉查找树不同，B树适用于读写相对大的数据块的存储系统，例如磁盘。它的应用是文件系统及部分非关系型数据库索引。
9. `B+树` 在B树基础上，为叶子结点增加链表指针 (B树+叶子有序链表)，所有关键字都在叶子结点 中出现，非叶子结点作为叶子结点的索引；B+树总是到叶子结点才命中。通常用于关系型数据库 (如Mysql)和操作系统的文件系统中。
10. `B*树` 是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针, 在B+树基础上，为非叶子结点也增加链表指针，将结点的最低利用率从1/2提高到2/3。
11. `R树` 是用来做空间数据存储的树状数据结构。例如给地理位置，矩形和多边形这类多维数据建立索引。
12. `Trie树`是自然语言处理中最常用的数据结构，很多字符串处理任务都会用到。Trie树本身是一种有限状态自动机，还有很多变体。什么模式匹配、正则表达式，都与这有关。



## reference
[图解：数据结构中的各种「树」，你都心中有数吗？](https://mp.weixin.qq.com/s/AnQAMgo2en7nksxFXqLBVg)
1. 什么是树
2. 什么是二叉树
3. 二叉树的遍历
4. 二叉树的节点是无序的，查找数据最坏可能遍历整个树
5. 对二叉树中数据进行排序
6. 二叉查找树
7. 二叉查找树的查询复杂度取决于目标节点的深度，因此当节点的深度比较大时，最坏的查询效率是O (n)，其中n是树中的节点个数。
8. 对二叉查找树进行改进
9. AVL树，平衡二叉查找树
	1. 在二叉查找树中，任一节点对应的两棵子树的最大高度差为 1，这样的二叉查找树称为平衡二叉树。其中左右子树的高度差也有个专业的叫法：平衡因子。
10. 一旦由于插入或删除导致左右子树的高度差大于1，AVL树就会旋转达到平衡。查找、插入和删除在平均和最坏情况下的时间复杂度都是O(log n)
11. B树是所有节点的平衡因子均等于0的多路查找树（AVL树是平衡因子不大于 1 的二路查找树）
12. 红黑树：从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。
13. 红黑树  VS  平衡二叉树（AVL树）
	1. 一般认为红黑树的删除和插入会比AVL树更快。因为AVL树严格要求平衡因子小于1，所以可能多次旋转，而红黑树最多三次旋转
	2. 查找操作，AVL树的效率更高。因为AVL树设计比红黑树更加平衡，不会出现平衡因子超过 1 的情况，减少了树的平均搜索长度。
14. Trie树（前缀树或字典树）
	1. 根节点不包含字符，除根节点外每一个节点都只包含一个字符。
	2. 从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串。
	3. 每个节点的所有子节点包含的字符都不相同。

[一文了解 8 种常见的数据结构](https://mp.weixin.qq.com/s/Q1zl3AkcfwAizOU4-0-NtA)
1. 数组
2. 链表
3. 栈
4. 队列
5. 树
	1. 无序树
	2. 二叉树
	3. 完全二叉树
	4. 满二叉树
	5. 二叉查找树
	6. 平衡二叉树
	7. 红黑树
	8. B树
6. 堆
	1. 大顶堆
	2. 小顶堆
7. 图
8. 哈希表

