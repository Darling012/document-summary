# 异步
## 问题
1. 为什么需要异步
2. 异步实现的几种方式
3. Promise/Future（这只是形式，底层是什么）
4. cpu 调度算法（时间片轮转 优先级调度 多级反馈队列）不同对于线程、异步的影响
	1. 比如一个异步线程在等待网络 io，但是 cpu 切换出去了，切进来时网络 io 正好完成了
5. 

## 什么是异步
**异步是一种消息通信机制**，是一种行为。同步的时候 调用——等待结果——返回结果。异步 调用——回应。回调结果。在同步等待的过程中，即结果返回前，当前线程被挂起，就造成了阻塞。在异步的时候，即使没有立即得到结果，也不会阻塞。
==为什么需要异步==
异步是为了更细粒度利用资源。
==同步、异步、阻塞、非阻塞==
![BIONIOAIO](BIONIOAIO.md#同步、异步、阻塞、非阻塞)

==怎么实现异步==
1. 回调
2. 轮询
3. 协程
4. [mq](mq.md)

## 异步编程模型

[异步编程模型的思考 | Laravel China 社区](https://learnku.com/articles/62232)
1. 什么是异步编程
	1. 同步 / 异步：是指程序自始至终都在用一个时间线上运行，异步则是我程序是主时间线上出现了别的时间线分支。
2. 异步编程解决了什么问题
	1. 是高效地解决并发问题，获得更高的并发请求
3. 异步编程具体实现方案
	1. 事件轮询
		1. 将数据交互过程中出现的各种事件注册到一个事件队列中，再由一些其他的线程来异步消费处理
	2. [回调](回调、观察者、事件监听、发布订阅.md)
		1. 在事件轮询中的事件队列，当事件发生后，怎么处理后续逻辑？
		2. 将事件和回调函数绑定起来
		3. 事件触发后，利用回调处理后续业务逻辑，满足异步
	3. 协程
		1. 回调存在回调地狱，代码不符合人类思维等缺点
		2. 协程用同步代码的方式实现了异步
		3. 协程是一种轻量级线程，调度的逻辑完全就交给用户去控制。这样用户就可以在**遇到同步 IO 的时候** ，挂起当前协程转而执行下一个协程，整个代码逻辑都是顺序书写，被挂起的协程，等待下次再次调度执行。
4. 盘点主流语言和服务器软件异步模型
	1. nginx 是多进程 + 单进程 reactor 异步模型，网络请求事件都有 reactor 线程接管注册分发给 worker 进程去执行
	2. redis 单线程 reactor 异步模型 也是事件分发注册异步编程
	3. netty 单线程 reactor 异步模型
	4. swoole 多线程 reactor + 多进程 worker
	5. nodejs 单线程 + eventLoop
	6. Golang 单线程 Reactor + 多线程协程



[异步编程模型的说明](https://colobu.com/2016/02/26/Do-not-make-ignorance-as-fearless/)
各种语言的编程模型从内存实现上可以分为两类：
1.  **基于共享内存的模型**：采用单一的统一的内存镜像，并发单元通过共享内存进行通讯，比如 Java 中的线程
2.  **基于消息传递的模型**：每个并发单元包含自有的内存，并发单元通过消息交换进行通讯，比如 go channel，Scala Actor 等
从实现上来说，至少有三种模型实现：
1.  **基于线程的实现**： 大部分的操作系统（轻量级的进程、内核级、用户级）、Java、C、C++都是这种实现
2.  **基于 Actor 的实现**：Scala, Erlang 等
3.  **基于 Coroutine 的实现**：Haskell, Python 等

[白话并发模型和异步编程范式 · Joey's Tech Notes & Blogs](https://code2life.top/2021/05/31/0062-concurrent-model-async-programming/) #值得细看
1. cpu核心processor，一个processor运行一个thread
2. 当一个thread需要等待耗时得io操作时，为了高效就切换线程，线程间的上下文切换。
3. 当多核心时，内存数据就可能被俩核心执行的俩线程更改
	1. 这叫竞态条件（Race Condition）。解决这类问题，需要用到各种同步原语：从CPU硬件层面的CAS指令；到OS级别的临界区、信号量、互斥量；再到编程语言的原子类型、各种锁、同步栅栏、并发安全的集合，都是让内存数据能被多核CPU安全地修改。
4. 除了同步原语，还有两种方案
5. I/O多路复用 + 单线程模型
	1. JavaScript、node、redis
	2. 一个线程做计算，
6. 协程
	1. 协程之间有无调用栈：有栈协程和无栈协程
	2. 协程间是否存在从属关系：对称协程和非对称协程

3个并发模型
1. 同步原语
2. I/O多路复用 + 单线程模型
3. 协程

异步编程范式
1. 回调，但存在回调地狱
2. async/await/yield：熨平callback嵌套褶皱
3. 发布订阅模式
4. 函数响应式编程
5. CSP模型/Actor模型：回归同步调用，放到有栈的协程/线程。



### JS异步
简单查看慕课《再学 JavaScript ES(6-10)全版本语法大全》后，es 6 中 iterator 是解决复杂对象遍历问题，generator 基于 iterator 的迭代协议和可迭代协议，并且提供了 `yield` 让遍历停下来。promise 改善了 callback。
es8的 `async` 关键字是将函数的返回值包装为 `Promise.resolve(value)`, `await` 后边的表达式为 `Promise.resolve(value)`，也就是 `async/await` 是对 `promise的语法糖`。通过这俩关键字实现了以同步的方式写异步的代码，即比如伪代码是异步停顿 3 秒输出 1，当下输出 2，不加这俩关键字是输出 2，1。加上能实现 1，2。
ps:  [Async/Await 如何通过同步的方式实现异步 - 掘金](https://juejin.cn/post/6844903891021086734)里提到 `async/await` 是对 `generator 的语法糖`，这个靠谱些，虽然 `async/await` 中既有 `generator` 又有 `promise`
[浅谈Generator和Promise原理及实现 - 掘金](https://juejin.cn/post/6844903652445044749)

[JavaScript异步机制详解 - 掘金](https://juejin.cn/post/6844903556084924423)

[聊聊 JavaScript 的并发、异步和事件循环 | 云音乐大前端专栏](https://musicfe.com/eventloop/)

[异步编程 – 李立超 | lilichao.com](https://www.lilichao.com/index.php/2022/10/10/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/)

[异步编程那些事](https://yanhaijing.com/javascript/2017/08/02/talk-async/)
1. 回调函数
	1. 回调的 N 大罪状
	2. 怎么捕获异常
		1. 分离回调，ajax 方案，`$.ajax({}, success, error);`
		2. first error，`function callback(err, data){if(err){}}`
2. 事件监听
3. 观察者
4. promise
	1. Promise 其实是一种控制反转，举个例子，就是原来我们要给异步函数传入一个回调函数，现在变成了异步函数返回一个 Promise 对象
5. generator
	1. es2015(es6)中引入，让原本必须一次执行完毕函数，现在可以在中间暂停，并在下次继续执行，这就让 js 可以模拟协程的概念
	2. generator 实现异步除了基于 Promise，还可以基于 thunk 函数
6. async/await
	1. es2017(es8)给我们带来了异步函数

### java
[Java 异步编程最佳实践](https://colobu.com/2015/03/24/Best-Practices-of-Asynchronous-Programming-With-Java/)

[一文带你彻底了解Java异步编程 - 老K的Java博客](http://javakk.com/563.html)
1. 什么是异步编程
	1.  响应式编程 + NIO
2. 什么是响应式编程？
	1. 响应式可以简单的理解为收到某个事件或通知后采取的一系列动作，如上文中所说的响应操作系统的网络数据通知，然后以**回调的方式**处理数据。
3. 它和传统的编程方式有什么区别？
	1. 传统的命令式编程主要由：顺序、分支、循环 等控制流来完成不同的行为
4. 响应式编程的特点是：
	1. 以逻辑为中心转换为以数据为中心
	2. 从命令式到声明式的转换

[使用Spring Reactor优化推荐流程 - songtianer - 博客园](https://www.cnblogs.com/songjiyang/p/16960263.html)

[一次线上事故，我顿悟了异步的精髓 - 掘金](https://juejin.cn/post/7118580043835506725)
多请求写库场景，用异步解决资源问题
1. 线程池
2. 先写本地内存+定时任务入库
3. mq
4. 先写入本地文件+agent 服务监听文件+agent 发送文件到 mq

## RPC中的异步
[深入剖析通信层和RPC调用的异步化（上）\_架构\_李林锋\_InfoQ精选文章](https://www.infoq.cn/article/q3ipeyqv-uf5ysisq62c)
[深入剖析通信层和RPC调用的异步化（下）\_架构\_李林锋\_InfoQ精选文章](https://www.infoq.cn/article/qkxxy3ir*c84oxmsf5qh)

## reference

[从根本上了解异步编程体系](https://mp.weixin.qq.com/s/q6BfOINeqgm5nffrHu4kQA) #值得细看 
1. cpu>>内存>>ssd>>机械硬盘>>网络 IO
2. web 服务都是 IO 密集型，收到请求 -> 查数据库 -> RPC 别的几个服务 -> 组合一下数据 -> 返回
3. 异步不是让单个任务更快，而是在相同时间内完成更多的任务。
	1. 单个异步任务绝不会比同步任务执行得更快
	2. 异步并不会让逻辑上串行的任务变快，只能让逻辑上可以并行的任务执行更快
4. 主要讲了怎么演化到 js 的promise


[异步编程概览 | Peanuts' Blog](https://peanut996.cn/2021/10/31/asynchronous-programming-overview/)
1. 异步实现
	1. 回调
		1. 这里的回调函数（callback）被称为是延续（continuation），即这个回调函数决定了程序接下来的行为，整个程序的逻辑就是通过一个个的延续而拼接在一起。
	2. Promise/Future/Delay/Deferrd
		1. promise 和 future 便是不同的东西，但是他们的共同点-有限状态机。他们也叫无栈协程。
	3. async/await
	4. 异步任务调度器




[异步编程的几种方式 | Coding Husky](https://ericfu.me/several-ways-to-aync/)
==什么是 cps?==
1. 把一个计算过程在中间打断，剩下的部分用一个对象表示，这就是 Continuation。操作系统暂停一个线程时保存的那些现场数据，也可以看作一个 Continuation。有了它，我们就能在这个点接着刚刚的断点继续执行。
2. 打断一个计算过程听起来很厉害吧！实际上它每时每刻都在发生——假设函数 f() 中间调用了 g()，那 g() 运行完成时，要返回到 f() 刚刚调用 g() 的地方接着执行。这个过程再自然不过了，以至于所有编程语言（汇编除外）都把它掩藏起来，让你在编程中感觉不到调用栈的存在。
3. 操作系统用昂贵的软中断机制实现了栈的保存和恢复。那有没有别的方式实现 Continuation 呢？最朴素的想法就是，把所有用得到的信息包成一个函数对象，在调用 g() 的时候一起传进去，并约定：一旦 g() 完成，就拿着结果去调用这个 Continuation。
4. 这种编程模式被称为 Continuation-passing style（CPS）
5. 这也就是回调函数
在 BIO 中，线程发起 IO 之后只能暂停，然后等待 IO 完成再由操作系统唤醒。而异步 IO 中，进程发起 IO 操作时也会一并输入回调（也就是 Continuation），这大大解放了生产力——现场无需等待，可以立即返回去做其他事情。一旦 IO 成功后，AIO 的 Event Loop 会调用刚刚设置的回调函数，把剩下的工作完成。这种模式有时也被称为 Fire and Forget。
==一颗语法糖：Promise==
回调函数的问题
1. 所有函数都要传入一个λ表达式，回调地狱
2. 细节处理麻烦，比如异常
**Promise 是对异步调用结果的一个封装**，在 Java 中它叫作 CompletableFuture (JDK8) 或者 ListenableFuture (Guava)。
1. 我现在还不是真正的结果，但是承诺以后会拿到这个结果。假如用 Promise.get() 强行要拿到结果，顺便阻塞了当前线程，异步变成了同步。
2.  改善了 Callback 的可读性，回调函数不再是传给 g()，而是 g() 返回的 Promise
==反应式编程==
Reactive 可以看作是对 Promise 的极大增强，相比 Promise，反应式引入了流（Flow）的概念。与 Promise 不同的是，事件可能被触发多次，所以处理代码也会被多次调用。
==CPS 变换：Coroutine 与 async/await==
异步编程终于摆脱了回调函数！唯一要做的只是在异步函数调用时加上 await，编译器就会自动把它转化为协程（Coroutine），而非昂贵的线程。
**函数已经不再是一个函数了，而是变成一个状态机**。每次 call 它、或者它 call 其他异步函数时，状态机都会做一些计算和状态轮转。
==终极方案：用户态线程==
比如硬件有 8 个核心，那就创建 8 个系统线程，然后把 N 个用户线程调度到这 8 个系统线程上跑。N 个用户线程的调度在用户进程里实现，由于一切都在进程内部，切换代价要远远小于操作系统 Context Switch。另一方面，所有可能阻塞系统级线程的事情，例如 `sleep()`、`recv()` 等，用户态线程一定不能碰，否则它一旦阻塞住也就带着那 8 个系统线程中的一个阻塞了。Go Runtime 接管了所有这样的系统调用，并用一个统一的 Event loop 来轮询和分发。
==总结==
以上方案中，Promise、Reactive 本质上还是回调函数，只是框架的存在一定程度上降低了开发者的心智负担。而 async/await 和用户态线程的解决方案要优雅和彻底的多，前者通过编译期的 CPS 变换帮用户创造出 CPS 式的函数调用；后者则绕开操作系统、重新实现一套线程机制，一切调度工作由 Runtime 接管。


[异步编程 -解道Jdon](https://www.jdon.com/asynchronous.html)
1. 异步编程通常是通过 fire and forget 方式实现，发射事件后即忘记，做别的事情了，无需立即等待刚才发射的响应结果了。(发射事件的地方称为生产者，而将在另外一个地方响应事件的处理者称为消费者)
2. 关键问题是我们为什么要等待响应呢？因为希望基于响应再继续执行一些逻辑，换一个思路，将这些逻辑移植到事件的消费者那里去做，而不是在当前生产者实现，这其实也是 reactive 编程的一个特点。
3. 比如 x 是1,y=x+1，那么 y 是2, 如果 x 变为3，y 还是3，通过 reactive 函数编程，时刻观察 x 变化，x 一旦变为3，观察者也就是消费者响应将 y 变成3+1。
4. 所以，异步编程是一种事件驱动编程，需要完全改变思路，将“请求响应”的思路转变到“事件驱动”思路上，是一种软件编程思维的转变。


[在 Java、Python、JavaScript 和 Go 中实现异步编程比较](https://www.jdon.com/65881.html)