# 协程
##### 问题
1. 无栈协程本质是个状态机怎么理解
2. 当前对协程简单理解
	1. ~~协程主要解决 io 密集型应用 io 阻塞问题，在单线程内提高了 io 并发效率。并且，协程调度，解决了内核 io 的异步通知。~~
	2. cpu 时间片轮转到当前线程，假如当前线程执行了 io 操作，那么就会阻塞挂起，造成上下文切换。假如用了协程，在时间片单位内，就可以先执行同线程别的操作，尽可能的跑满时间片再切出去，即单线程并发。
		1. 有个疑问，就是阻塞挂起不用协程会不会导致 cpu 切出去？
3. 协程调用非阻塞IO，但是时间片跑完后，仍然没有数据返回后续是怎么一个机制？
4. 没跑满时间片，也还没数据返回时，会让出cpu吗？

##### 和IO的联系
[理解协程，以及协程如何提升IO阻塞时的性能\_协程 阻塞\_Helloworld先生的博客-CSDN博客](https://blog.csdn.net/u010841296/article/details/89608492)	

[协程是碰着阻塞式I\\O会导致整个线程被挂起么？ - 知乎](https://www.zhihu.com/question/321006574)
1. 解释了协程不能调用阻塞式的IO，因为会造成线程阻塞让出CPU
2. 所以协程库要尽可能的对阻塞API进行封装
3. GO的协程调度是限制每个协程只能运行10ms，超时就认为是阻塞操作，转移到别的线程中执行。
4. 所以协程应该配合非阻塞IO使用

[解密协程是如何实现的？ - 古明地盆 - 博客园](https://www.cnblogs.com/traditional/p/12609648.html)
1. 
##### 和多路复用关系
[多路复用、非阻塞、线程与协程 - 御坂研究所](https://www.nosuchfield.com/2019/01/09/Multiplex-and-non-blocking-and-threading-and-coroutine/)
1. BIO 中，读写事件和读写操作是糅合在一起的。
2. 用户想要读取数据只需要调用 read 系统调用，然后线程阻塞直到当前连接的读缓冲区有数据可读，此时操作系统会调度线程退出阻塞，在用户态的我们就可以实现读取数据的操作了。
3. 此时是用一个线程实现一个连接的读写，当前线程的阻塞并不会对其它的连接产生影响，所以阻塞也无所谓。
4. 然后出现了c10K问题，也就是如何让一个操作系统能同时维护10k个连接。
5. BIO 中，TCP 连接的可读可写事件以及读写操作本身都被实现在 READ 和 WRITE 系统调用中，而读写事件本身会阻塞当前线程，这也就导致了我们必须要给每一个读写操作分配一个单独的线程。
6. 因为传统 IO 需要一个连接对应着一个线程，所以当连接数过多时线程数也很多
7. 现代操作系统使用多路复用和非阻塞来解决C10K问题，它们的核心在于细化了对连接的管理方式。
8. 以前我们管理连接只能使用 READ 和 WRITE，然后无脑开个线程，让操作系统来帮助我们管理连接的可读可写事件。为了解决这些问题，我们开始需要自己管理连接的读写事件。
9. 首先我们把连接的操作进行拆分，不再像以前那样 READ 和 WRITE 一把梭，而是把**可读可写**和**读写操作本身**进行拆分。我们之前说过，我们之所以要给每一个连接创建一个线程，是为了能让操作系统帮助我们管理每一个连接的读写事件。
10. 我们把一个连接的可读可写事件剥离出来，使用单独的线程来对其进行管理，这里的关键点在于此线程不仅可以管理一个线程的可读可写事件，事实上这个线程中我们可以管理多个连接的可读可写事件，这个线程中实现的操作就叫**多路复用**，多路复用需要操作系统提供相应的 syscall 才可以使用。
11. 因为读写操作本身也可能导致线程阻塞（例如读取数据的数量还不满足要求），所以此时我们仍然需要为每一个连接的读写操作开辟新的线程（也可以使用线程池）
12. 使用非阻塞 IO，即一旦当前连接读缓冲区中的数据已被读完或当前连接的写缓冲区中的数据已满，则 READ 或 WRITE 系统调用立即返回，而不是阻塞住当前线程。有了非阻塞 IO，我们就可以在一个线程中进行多个连接的读写操作而不用担心某一个连接会导致当前线程阻塞，这样我们就能降低读写操作所需要的线程的数量了。
13. 由于多路复用与非阻塞的使用，导致单个连接的状态管理不再像 BlockIO 时那样的简单，而且因为线程不会阻塞在读写操作、尤其是读操作上，所以此时我们一般使用回调函数的方式来实现读操作。
14. 单来说就是在读取时，如果已经读取的数据还不满足需求，程序就暂时把这些数据读取并保存在用户态的内存中，待数据读取满足要求之后就调用回调函数，通过异步的方式把数据交给相应的处理函数。
15. 异步的问题在于不便于程序员的理解，人类更加习惯于同步的操作行为
16. 我们可以使用协程对多路复用和非阻塞进行改造来实现同步的 IO 操作。
17. [BIONIOAIO](BIONIOAIO.md)

[[求教] 协程与 IO 多路复用区别？]( https://v2ex.com/t/690868 )
1. 都学过操作系统，操作系统的功能之一就是提供硬件的访问接口，例如：网络 IO  
2. 协程是“用户态”的概念，IO 多路复用是系统调用的接口，是“用户态”与“内核态”交互的方式；毕竟协程是无法直接访问网卡缓冲区的，需要调用系统接口来获取网络 IO 的数据。
3. 所以网络程序，协程一般需要搭配 IO 多路复用才能发挥最大威力，协程提升并发处理的能力，网络 IO 能力就要靠 IO 多路复用。

##### 对比CompletableFuture
[深入理解Kotlin协程笔记（一） – Dylech30th's Blog](https://sora.ink/archives/429)
##### goto 与协程
goto 是在同一个函数中跳转, 协程应该类似于 setjump 和 longjump，这个是在不同函数间跳转。
协程一个主要功能就是跨函数的 goto，当然，在需要时还能 goto 回来，这一点更像函数调用。
[程序间的跳跃与协作——谈谈协程的运用 - 简书](https://www.jianshu.com/p/c7f28af97b67)
## 进程、线程、协程
变量是否隔离
上下文是否自动切换

[【对比Java学Kotlin】协程简史 - 掘金](https://juejin.cn/post/7116898730166452232)

[【协程第一话】协程到底是怎样的存在？\_哔哩哔哩\_bilibili](https://www.bilibili.com/video/BV1b5411b7SD/?spm_id_from=333.337.search-card.all.click&vd_source=64d78ba24411c8f1d039dc5922514872)

[初识协程 | 楚权的世界](http://chuquan.me/2021/05/05/getting-to-know-coroutine/)
1. 一个线程多个协程的情况下，在内核看来只有一个线程在运行，这些协程事实上是在串行运行，只能使用一个 CPU 核。因此，想要高效利用 CPU，我们还是得使用线程。协程最大的优势在于 协程的切换比线程的切度更快。那么，什么场景下更适合使用协程呢？
2. 答案是：IO 密集型任务。IO 密集型任务的特点是 CPU 消耗少，其大部分时间都是在等待 IO 操作完成。对于这样的场景，一个线程足矣，因此适合采用协程。
3. 按照是否开辟相应的调用栈保存协程状态分为
	1. 有栈协程
	2. 无栈协程


[14 用户态和内核态：用户态线程和内核态线程有什么区别？.md](https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E9%87%8D%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%AE%8C/14%20%20%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81%EF%BC%9A%E7%94%A8%E6%88%B7%E6%80%81%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81%E7%BA%BF%E7%A8%8B%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F.md)
1. 很多操作系统，将内存分为了两个区域
	1. 内核空间
		1. 只有内核程序可以访问
	2. 用户空间
		1. 专门给应用程序访问
2. 内核态
	1. 内核空间里的代码可以访问所有内存
3. 用户态
	1. 用户空间里的代码被限制只能使用一个局部的内存空间
	2. 
4. 系统调用过程
	1. 内核程序执行在内核态（Kernal Mode），用户程序执行在用户态（User Mode）
	2. 当发生系统调用时，用户态的程序发起系统调用。因为系统调用中牵扯特权指令，用户态程序权限不足，因此会中断执行，也就是 Trap（Trap 是一种中断）。
	3. 发生中断后，当前 CPU 执行的程序会中断，跳转到中断处理程序。内核程序开始执行，也就是开始处理系统调用。内核处理完成后，主动触发 Trap，这样会再次发生中断，切换回用户态工作。
5. 一个应用程序启动后会在内存中创建一个执行副本，这就是进程。
6. Linux 的内核是一个 Monolithic Kernel（宏内核），因此可以看作一个进程。也就是开机的时候，磁盘的内核镜像被导入内存作为一个执行副本，成为内核进程。
7. 进程可以分成
	1. 用户态进程
		1. 通常是应用程序的副本
	2. 内核态进程
		1. 就是内核本身的进程
8. 如果用户态进程需要申请资源，比如内存，可以通过系统调用向内核申请
9. 用户态进程如果要执行程序，是否也要向内核申请呢？
	1. 不需要
10. 一个进程可以拥有多个线程。进程创建的时候，一般会有一个主线程随着进程创建而创建。
11. 如果进程想要创造更多的线程
	1. 可以通过 API 创建用户态的线程
	2. 也可以通过系统调用创建内核态的线程
12. 用户态线程
	1. 操作系统内核并不知道它的存在，它完全是在用户空间中创建。
13. 内核态线程
	1. 可以通过系统调用创造一个内核级线程
14. 用户态线程和内核态线程之间的映射关系（思想关联：线程池、rpc 调用、mq 等）
	1. 多对一
	2. 一对一
	3. 多对多
	4. 两层设计
15. 总结
	1. 用户态线程工作在用户空间，内核态线程工作在内核空间。
	2. 用户态线程调度完全由进程负责，通常就是由进程的主线程负责。
	3. 相当于进程主线程的延展，使用的是操作系统分配给进程主线程的时间片段。
	4. 内核线程由内核维护，由操作系统调度。

[17 进程和线程：进程的开销比线程大在了哪里？.md](https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E9%87%8D%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%AE%8C/17%20%20%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%BC%80%E9%94%80%E6%AF%94%E7%BA%BF%E7%A8%8B%E5%A4%A7%E5%9C%A8%E4%BA%86%E5%93%AA%E9%87%8C%EF%BC%9F.md)
1. 进程（Process），顾名思义就是正在执行的应用程序，是软件的执行副本。而线程是轻量级的进程。
2. 进程是分配资源的基础单位。线程是程序执行的基本单位。
3. 设计进程和线程，操作系统需要思考分配资源。最重要的 3 种资源是：计算资源（CPU）、内存资源和文件资源。
4. 进程下面，需要一种程序的执行单位，仅仅被分配 CPU 资源，这就是线程。分配的方式，就是由操作系统调度线程。
5. 操作系统创建一个进程后，进程的入口程序被分配到了一个主线程执行，这样看上去操作系统是在调度进程，其实是调度进程中的线程。这种被操作系统直接调度的线程，我们也成为内核级线程。
6. 有的程序语言或者应用，用户（程序员）自己还实现了线程。相当于操作系统调度主线程，主线程的程序用算法实现子线程，这种情况我们称为用户级线程。
7. 分时和调度：现代操作系统都是直接调度线程，不会调度进程。
8. 进程和线程的设计
	1. 进程和线程在内存中如何表示？需要哪些字段？
		1. 进程表
			1. 进程在内存中的存放位置、PID 是多少、当前是什么状态、内存分配了多大、属于哪个用户等
			2. 即分为
				1. 描述信息：这部分是描述进程的唯一识别号，也就是 PID，包括进程的名称、所属的用户等。
				2. 资源信息：这部分用于记录进程拥有的资源，比如进程和虚拟内存如何映射、拥有哪些文件、在使用哪些 I/O 设备等，当然 I/O 设备也是文件。
				3. 内存布局：操作系统也约定了进程如何使用内存
		2. 线程表
			1. 线程也需要 ID， 可以叫作 ThreadID。 
			2. 自己的执行状态（阻塞、运行、就绪）
			3. 优先级、程序计数器以及所有寄存器的值等等
				1. 线程需要记录程序计数器和寄存器的值，是因为多个线程需要共用一个 CPU，线程经常会来回切换，因此需要在内存中保存寄存器和 PC 指针的值。
		3. 用户级线程和内核级线程映射关系表
	2. 进程代表的是一个个应用，需要彼此隔离，这个隔离方案如何设计？
	3. 操作系统调度线程，线程间不断切换，这种情况如何实现？
	4. 需要支持多 CPU 核心的环境，针对这种情况如何设计？

[进程、线程，cpu核数的关系 | Rongyao👨‍💻](http://rongyaois.top/%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%EF%BC%8Ccpu%E6%A0%B8%E6%95%B0%E7%9A%84%E5%85%B3%E7%B3%BB/)
1. 多核 CPU，不同的核通过 L 2 cache 进行通信，存储和外设通过总线与 CPU 通信。
2. 多个物理 CPU，CPU 通过总线进行通信，效率比较低。
3. 父进程和子进程
4. 子进程和线程区别
	1. 进程和线程的区别在于粒度不同, 进程之间的变量 (或者说是内存)是不能直接互相访问的, 而线程可以, 线程一定会依附在某一个进程上执行.
5. 线程是进程中的单位，是占用 CPU 的单位，例如 4 内核 CPU，如果有 4 个线程，这个 4 个线程是并行 (不是并发)。
6. 该电脑拥有 1 个 CPU，它有 4 个内核（表示有 4 个相对独立的 CPU 核心单元组，这是物理概念），每个内核有个 4 线程。
7. 即单 CPU 4 核心 4 线程（??？不是 8 线程？）
	1. 4 核 指的是物理核心（物理概念）
	2. 4 线程（线程数是一个逻辑概念） 是通过超线程技术，用一个物理核模拟两个虚拟核（逻辑处理器），所以每个物理核 2 个线程，总数为 8 线程，在操作系统看来是 8 核，实则是 4 个物理核。
8. 在超线程技术中的线程是否是真正的并行呢？
	1. 不是所有的线程都是并行的，只能说恰好碰到两个线程当前要执行的指令不使用相同的 CPU 资源时才可以真正地并行执行。

[一文读懂什么是进程、线程、协程](https://www.cnblogs.com/Survivalist/p/11527949.html)
1. 进程
	1. 程序：控制进程执行的指令集
	2. 数据集合：执行时数据和工作区
	3. 进程控制块（PCB）：进程的描述和控制信息，是进程存在的唯一标志
2. 线程
	1. 各个线程之间共享程序的内存空间 (也就是所在进程的内存空间)
	2. 一个标准的线程由线程 ID、当前指令指针 (PC)、寄存器和堆栈组成。而进程由内存空间 (代码、数据、进程空间、打开的文件)和一个或多个线程组成。（读到这里可能有的读者迷糊，感觉这和 Java 的内存空间模型不太一样，但如果你深入的读过深入理解 Java 虚拟机这本书的话你就会恍然大悟）
3. 任务调度
	1. 时间片轮转的抢占式调度方式
	2. 在一个**进程**中，当一个**线程任务**执行几毫秒后，会由**操作系统的内核**（负责管理各个任务）进行调度，通过硬件的计数器中断处理器，让该线程强制暂停并将该线程的寄存器放入内存中，通过查看线程列表决定接下来执行哪一个线程，并从内存中恢复该线程的寄存器，最后恢复该线程的执行，从而去执行下一个任务。
4. 进程和线程的区别
	1. 线程是程序执行的最小单位，而进程是操作系统分配资源的最小单位；
	2. 进程之间相互独立，但同一进程下的各个线程之间共享程序的内存空间 (包括代码段、数据集、堆等)及一些进程级的资源 (如打开文件和信号)，某进程内的线程在其它进程不可见；
5. 多线程与多核
6. 内核线程
	1. 每一个处理核心对应一个内核线程
	2. 现在采用超线程技术，将一个 cpu 对应两个内核线程，使用**线程级并行计算**（是真的并行吗？）
	3. 内核线程（Kernel Thread，KLT）就是直接由操作系统内核支持的线程，这种线程由内核来完成线程切换，内核通过操作调度器对线程进行调度，并负责将线程的任务映射到各个处理器上
7. 用户线程
	1. 程序一般不会直接去使用内核线程，而是去使用内核线程的一种高级接口——轻量级进程（Lightweight Process，LWP），轻量级进程就是我们通常意义上所讲的线程，也被叫做用户线程。由于每个轻量级进程都由一个内核线程支持
8. 内核线程与用户线程对应模式
	1. 一对一
		1. 一个用户线程对应一个内核线程，一个内核线程不一定有用户线程
	2. 多对一
		1. 多个用户线程对应一个内核线程
		2. 其他 cpu 岂不是没用了
		3. 线程之间的切换由用户态的代码来进行，系统内核感受不到线程的实现方式。用户线程的建立、同步、销毁等都在用户态中完成，不需要内核的介入。
	3. 多对多
		1. 由线程库负责调度（是系统的吗？）
9. 协程
	1. 是一种基于线程之上，但又比线程更加轻量级的存在
	2. 由程序员自己写程序来管理的轻量级线程叫做『用户空间线程』，具有对内核来说不可见的特性。
	3. 一个线程也可以拥有多个协程。
10. 协程的目的
	1. 当线程遇到耗时的 io 操作，就会阻塞，cpu 空转，线程间切换是操作系统负责开销大，目前解决方式是单线程+异步回调。比如 vert.x。
	2. 协程的目的就是当出现长时间的 I/O 操作时，通过让出目前的协程调度，执行下一个任务的方式，来消除 ContextSwitch 上的开销。
11. 协程与线程的区别
	1. 线程的切换由操作系统负责调度，协程由用户自己进行调度，因此减少了上下文切换，提高了效率
		1. 由于协程的暂停完全由程序控制，发生在用户态上；而线程的阻塞状态是由操作系统内核来进行切换，发生在内核态上。因此，协程的开销远远小于线程的开销，也就没有了 ContextSwitch 上的开销。
	2. 不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多
	3. 场景
		1. 协程：适用于被阻塞的，且需要大量并发的场景。
		2. 线程：大量计算的多线程
12. 协程的原理
	1. 当出现 IO 阻塞的时候，由协程的调度器进行调度，通过将数据流立刻 yield 掉（主动让出），并且记录当前栈上的数据，阻塞完后立刻再通过线程恢复栈，并把阻塞的结果放到这个线程上去跑

[深入分析 Java、Kotlin、Go 的线程和协程-腾讯云开发者社区-腾讯云](https://cloud.tencent.com/developer/article/1958174)
1. Java
	1. Java 在 Linux 操作系统下使用的是用户线程+轻量级线程，一个用户线程映射到一个内核线程，线程之间的切换就涉及到了上下文切换。所以在 Java 中并不适合创建大量的线程，否则效率会很低
2. 协程大法好，比线程更轻量级，但是仅针对 I/O 阻塞才有效；对于 CPU 密集型的应用，因为 CPU 一直都在计算并没有什么空闲，所以没有什么作用。
3. Kotlin 兼容 Java，在编译器、语言层面实现了协程，JVM 底层并不支持协程；Go 天生就是支持协程的，不支持多进程和多线程。Java 的 `Project Loom` 项目支持协程，



[为什么 Java 坚持多线程不选择协程？ - 知乎](https://www.zhihu.com/question/332042250)
1. 



## 协程的作用
[浅谈协程 - 张小凯的博客](https://jasonkayzk.github.io/2022/06/03/%E6%B5%85%E8%B0%88%E5%8D%8F%E7%A8%8B/)
假设每次业务处理花费在 RPC 调用上的耗时是 20 ms，那么一条线程一秒最多处理 50 次请求！
如果在等待 RPC 返回时当前线程没有被系统调度转换为 Ready 状态，那当前 CPU 核心就会空转，浪费了 CPU 资源！通过增加线程数量提高系统吞吐量的效果非常有限，而且创建大量线程也会造成其他问题！
协程虽然不一定能减少一次业务请求的耗时，但一定可以提升系统的吞吐量：
- 当前业务只有一次第三方 RPC 的调用，那么协程不会减少业务处理的耗时，但可以提升 QPS；
- 当前业务需要多个第三方 RPC 调用，同时创建多个协程可以让多个 RPC 调用一起执行，则当前业务的 RPC 耗时由耗时最长的 RPC 调用决定；



[对协程的理解 - V2EX](https://v2ex.com/t/882689)
1. 协程 coroutine 重点在于 cooperative ，协作式，相对应的是 preemptive ，抢占式，最经典的实现既 Thread ，线程。
2. 这两者都是 multitasking 多任务的机制。
3. 协作式就是各个任务之间相互合作，程序主动在需要等待的时候让出控制权，体现在代码里就是 yeild/await 等机制，golang 则是由编译器隐式插入 yield 点。  
4. 抢占式自然是各个程序不协作，相互争抢，由外部调度器决定运行哪个。  
5. 前者的优点在于因为是程序自己协作，自然知道挂起 /恢复时需要哪些信息，而 OS 线程调度器不知道这些，就得把整个 call stack/ register 的状态都存下来以后才能恢复。这就是协程性能好、更轻量的原因。  
6. 抢占式的优点在于不需要用户代码关心和处理协作的细节，用户代码更简单且责任少。操作系统如果用协作式的多任务，那一个程序不让出控制权就能卡死整个系统，这也是通用操作系统实现线程的原因。而嵌入式操作系统等用户态可控的环境下，则可以实现协程作为多任务机制。  
7. stackful/stackless 是协程实现的方式，前者使用类似 stack 的结构保存状态，优点是编写时更接近传统线程，aka 绿色线程。后者则是生成状态机，只保存确实需要的状态，性能最好。
8. 异步是一种调用机制，指调用函数立即返回而不是完成后返回，完成后通过某种方式通知调用方再获取结果。回调和某些语言的 async/await 语法就是为了表达这个过程。  
9. 异步 IO 是指通过异步的方式提供 IO 接口，操作系统提供 epoll/io_uring/IOCP 等接口，上层应用 /运行时再封装，常常配和协程、async/await 语法等结合起来以简化使用。
10. 说异步 /协程提升性能主要指因为使用了异步 IO 接口，线程不会被阻塞，所以只需要少量线程而不是大量线程等待，少量线程内部再调度协程等待 IO 。因为协程更轻量，所以高并发场景下开销小，自然性能就好了。
11. Promise/Future 等是对异步过程的封装对象，和协程是相关但不同的两个概念。
12. goroutine 之所以叫 goroutine 而不是 coroutine 就是因为 goroutine 不是完全协作式的，也存在抢占式调度。

[某些语言的协程机制，其作用是什么，是否会造成额外的开销 - V2EX](https://v2ex.com/t/702723)
1. 比如说一个时间片是 10 ms，你的线程本来可以执行 10 ms 的代码，这段代码里你需要进行到网络 IO，所以因为 IO 问题，这个线程才执行了 1 ms 就被系统调度走，结果你这个线程才执行了 1 ms 。如果你在线程里使用协程，因为不需要切换到内核态，那么你在用协程进行网络 IO 的同时还可以运行其它代码，这样你可以充分利用 CPU，完成这 10 ms 的时间

[协程的好处有哪些？ - 知乎](https://www.zhihu.com/question/20511233)

[问一个协程方面的问题 - V2EX](https://www.v2ex.com/t/821871)
1. 协程主要针对的场景是 IO 阻塞的时候能够有轻量高效的处理大批量并发任务。对于大量并发的 CPU 开销（运算）来说，协程毫无用处，因为协程并不能协调 CPU 资源
2. 协程适用于 IO 密集场景，CPU 密集场景的并行还是只能靠线程来 比如 folk-join pool + work stealing 。协程还有个好处是结构化并发，代码可以线性书写，类似写同步逻辑一样
3. 和线程的区别？多协程可以有效利用单核心计算，避免过多的 IO 等待，多进程（线程）可以有效利用多核心计算，避免单核负载过高，不是一回事。
4. 



[【带着问题学】协程到底是什么? - 掘金](https://juejin.cn/post/6973650934664527885)

## 协程的实现
##### 抢占式和非抢占式
[协程入门，这可能是全网最简单易懂的扫盲贴了\_李兆龙的博客的博客-CSDN博客](https://blog.csdn.net/weixin_43705457/article/details/106857068)
1. 协程比线程出现的早
2. 最早的进程就是协作式多任务的模型
	1. 协作式就是非抢占式，即程序运行完后主动让出cpu
	2. 弊端是，有的程序一直占着不让
3. 所以，抢占式调度就公平的多，代表算法是时间片轮转调度算法
4. 当两个线程加锁解锁从执行到阻塞就伴随着用户态向内核态的切换，非抢占式的好处体现出来了
5. 不需要内核切换，我们自己掌握什么时候切协程
6. 协程本质上就是个用户态线程，实现一个协程库也就是实现一个用户态的调度器
7. 对于内核来说，我们在一个线程内申请十个协程。内核眼里是一个线程在不停地跑，我们眼里是十个协程在切换。
8. 

##### 有栈协程和无栈协程
[理解有栈无栈协程 | 求索阁](http://qiusuoge.com/16295.html)
1. 协程是分为有栈协程和无栈协程俩种. 区别在于是否有自己的调用栈来进行函数调用等操作
2. 每个协程切换的时候, 整个栈都会被切换, 看起来和线程没啥区别, 只是调度一个发生在用户态可以由用户控制, 一个发生在内核态由系统控制.
3. 无栈协程的实现
	1. 栈帧内保存的不是状态而是指向状态的指针. 
	2. 所有帧的状态保存在堆上
4. 理解了第二点, 就发现, 其实根本不需要上下文切换, 因为全局的上下文就没变过, 改变他们的调用关系就行 (栈)
5. 
[有栈协程与无栈协程\_有栈协程和无栈协程\_李兆龙的博客的博客-CSDN博客](https://blog.csdn.net/weixin_43705457/article/details/106924435)
1. 有栈无栈说的是协程之间是否存在调用栈

[初识协程 | 楚权的世界](http://chuquan.me/2021/05/05/getting-to-know-coroutine/)
[有栈协程与无栈协程](https://mthli.xyz/stackful-stackless/)




### 有栈协程
##### go

##### java
[次时代Java编程(一) Java里的协程 | 出续篇 更新ed - 力谱云 - SegmentFault 思否](https://segmentfault.com/a/1190000005342905)

###### 虚拟线程
[如果java虚拟线程稳定了，是不是有一大批框架和工具要重写？ - Robert的博客](https://robberphex.com/will-virtual-thread-make-us-rewrite-java-code/)
[Java下一代高并发技术——虚拟线程（Virtual Threads） | 老卫（柳伟卫）的博客 - 关注编程、系统架构、性能优化 | waylau.com](https://waylau.com/jep-425-virtual-threads-preview/)
[JDK21要来了，协程可以给Java带来什么 - Vergessen](https://www.vergessen.top/article/v/62020182292898134)
### 无栈协程
#### 状态机
[Generator做为状态机与普通状态机的区别及实现\_头发多多程序媛的博客-CSDN博客](https://blog.csdn.net/weixin_46816740/article/details/108453641)
[深入理解 Generators - 女王控的博客](https://blog.towavephone.com/deep-learn-generators/) 

[Python协程与JavaScript协程的对比 - 从零开始的程序员生活 - 博客园](https://www.cnblogs.com/lgjbky/p/14759463.html)

#### python 的协程




#### JS
[JS异步](异步.md#js%20异步)
[你是否对JS中的Generator及协程真正理解?-51CTO.COM](https://www.51cto.com/article/629106.html)
generator 的实现机制是协程，而不是反过来。那么是 v8 实现了协程？还是说还是基于 eventloop？
[Generator 协程工作原理](https://github.com/liam61/blog/blob/master/js/regenerator/index.md)
[详解 Event Loop（事件循环）机制 - 女王控的博客](https://blog.towavephone.com/js-event-loop/)

[一文读懂什么是进程、线程、协程 - 回首笑人间 - 博客园](https://www.cnblogs.com/Survivalist/p/11527949.html)

#### kotlin 的协程
[协程的原理还是没懂 - V2EX](https://www.v2ex.com/t/669096)
1. 就跟 c 语言的 goto 差不多，执行到某个地方 yield，函数就 return 了，再 resume 的时候又回到了上次 yield 的地方。只不过协程会帮你把函数堆栈都存好了，goto 回来的时候能继续找到上下文。

[Kotlin 协程真的比 Java 线程更高效吗？-腾讯云开发者社区-腾讯云](https://cloud.tencent.com/developer/article/1570462)
1. 说的是并不是真正协程还是基于 jvm
2. jvm 跟 os 的线程是 1 vs 1
3. 补充
	1. 同一个观点 [Kotlin 协程 - 扔物线](https://rengwuxian.com/tag/kotlin-coroutines/)
	2. 


## reference
1. 《042 - 协程原理从入门到精通 每个后端开发都需要掌握的高性能开发技术》
2. 《许式伟的架构课》11 | 多任务：进程、线程与协程
3. Java 并发编程实战  44 | 协程：更轻量级的线程
4. Java 性能调优实战 19 | 如何用协程来优化多线程业务？
5. Python 核心技术与实战 20 | 揭秘 Python 协程
6. 



[异步、并发、协程原理 - Howborn个人笔记](https://www.fanhaobai.com/2017/11/synchronised-asynchronized-coroutine.html)
1. 应用程序和内核
	1. 内核具有最高权限，可以访问受保护的内存空间，可以访问底层的硬件设备。而这些是应用程序所不具备的，但应用程序可以通过调用内核提供的接口来间接访问或操作。所谓的常见的 IO 模型就是基于应用程序和内核之间的交互所提出来的。以一次网络 IO 请求过程中的 read 操作为例，请求数据会先拷贝到系统内核的缓冲区（内核空间），再从操作系统的内核缓冲区拷贝到应用程序的地址空间（用户空间）。而从内核空间将数据拷贝到用户空间过程中，就会经历两个阶段
		1. 等待数据准备
		2. 拷贝数据
2. 同步和异步
	1. 同步（Synchronised）和异步（Asynchronized）的概念描述的是应用程序与内核的交互方式，同步是指应用程序发起 I/O 请求后需要等待或者轮询内核 I/O 操作完成后才能继续执行；而异步是指应用程序发起 I/O 请求后仍继续执行，当内核 I/O 操作完成后会通知应用程序，或者调用应用程序注册的回调函数。
3. 阻塞和非阻塞
	1. 阻塞和非阻塞的概念描述的是应用程序调用内核 IO 操作的方式，阻塞是指 I/O 操作需要彻底完成后才返回到用户空间；而非阻塞是指 I/O 操作被调用后立即返回给用户一个状态值，无需等到 I/O 操作彻底完成。
4. 协程与异步和并发的联系
	1. 协程与异步：协程并不是说替换异步，协程一样可以利用异步实现高并发。
	2. 协程与并发：协程要利用多核优势就需要比如通过调度器来实现多协程在多线程上运行，这时也就具有了并行的特性。如果多协程运行在单线程或单进程上也就只能说具有并发特性。

[异步并发编程实践之协程 | Netcan on Programming](https://netcan.github.io/2021/08/31/%E5%BC%82%E6%AD%A5%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%E4%B9%8B%E5%8D%8F%E7%A8%8B/)
1. 以单线程的调度器为根基，并发调度不同的协程
2. 因此使用协程的好处是可以做到无锁并发编程，没有死锁，没有回调，没有竞争，也就无需大量的状态
3. 单线程如何做到并发？并发从微观上看分时复用的，而从宏观角度看是同时进行的。早在单核时代便支持了线程机制，使用线程做并发，由操作系统进行调度实现并发。即便是单核，你也摆脱不了锁，因为一旦你是用了多线程编程，就不能对核数有任何假设，或许哪天你的机器升级后程序就异常了。
4. 使用协程没有这个问题，协程调度器充当了操作系统协程调度的角色，因此操作系统不感知上层应用的情况，也就不会涉及昂贵的上下文切换代价。
5. 从用户角度而言，使用线程，你的执行过程随时可能被切换，导致你不得不加锁、状态；使用协程，你的协程切换由你决定（使用 `await` 关键字）。这便是线程与协程的核心区别：前者切换权通常在操作系统上，后者切换权在用户手上（抢占与非抢占）。
6. 




[无栈协程 - RustStack.Org](https://ruststack.org/stackless-coroutine/)

[简单谈谈协程 - 掘金](https://juejin.cn/post/6961414532715511839)


[async/await异步模型是否优于stackful coroutine模型？ - 知乎](https://www.zhihu.com/question/65647171/answer/233495694)



[4G Spaces](https://blog.youxu.info/2014/12/04/coroutine/)


[14.程序员应如何理解协程 - 《计算机底层的秘密》 - 书栈网 · BookStack](https://www.bookstack.cn/read/webxiaohua-gitbook/14.-cheng-xu-yuan-ying-ru-he-li-jie-xie-cheng.md)






