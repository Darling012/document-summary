# Mysql 锁
## 问题
1. mysql 的乐观锁实现比如 version 在操作时跟 Record lock 的读锁啥关系？
	1. 没啥关系，表锁行锁都是在 mysql 的悲观锁下的实体锁。
	2. mysql 的乐观锁与悲观锁说的是思想，并不是数据库中实现的锁机制，是需要我们自己去实现的。


![隔离级别与锁的关系](事务.md#事务的隔离级别)
##### mysql 默认隔离级别
[MySQL 默认隔离级别是RR，为什么阿里这种大厂会改成RC？ - HollisChuang - 博客园](https://www.cnblogs.com/hollischuang/p/15522907.html)

## reference

[悲观锁和乐观锁](https://mp.weixin.qq.com/s?__biz=Mzg5OTA1MDgzMA==&mid=2247483990&idx=1&sn=b5e9dfd173f9ee630d71576d0a8087ea)
悲观锁和乐观锁的概念，悲观锁和乐观锁并不是具体的锁，也不是针对数据库或者某种语言来说的，而是一种思想。
1. 悲观锁
	1. 实现方式就是加锁
	2. 主要应用于多写场景
		1. 数据库中常见的有 update/delete 等操作
		2. 对于显式读如 select ... for update/select ... lock in share mode 等，也会加锁
		3. 加锁分成写锁/读锁/行锁/表锁/record lock/gap lock/next-key lock 等
2. 乐观锁
	1. 实现方式主要有
		1. cas 算法
		2. 版本号控制（mvcc 有用到）
	2. 主要应用于多读场景

[MySQL各种锁](https://mp.weixin.qq.com/s?__biz=Mzg5OTA1MDgzMA==&mid=2247483770&idx=1&sn=74c45a1d028f1d2213bd137f899d1a92)
1. InnoDB 中的锁定技术往往是基于索引实现的
2. SQL 中没有利用到索引的话，往往会执行全表扫描，触发表锁。
3. 所以从效率上来说，我们应该建立合适的索引，减少锁的数据行提高并发。
4. 锁的粒度上来说，可以将锁分为表锁和行锁

从行锁的角度上来说，InnoDB 存储引擎实现了两种标准的行级锁，共享锁 (读锁)和排他锁 (写锁)。
1. 共享锁：当一个事务获取了某行数据的共享锁后，其他事务依然可以对这行数据加共享锁，但是不能加排他锁。
2. 排他锁：当一个事务获取了某行数据的排他锁后，其他事务不可以对这行数据加任何锁。

从锁的范围来说，行锁还可以分成
1. record lock：索引的记录锁，是建立在索引记录上的，如果没有索引的情况，往往会触发表锁。
2. gap lock：加在索引记录间隙上的锁。
3. next-key lock：record lock+gap lock 的组合，用来在 RR 级别解决幻读的问题；所以通常在 insert 时，会锁定相邻的键。


[MySQL锁](https://mp.weixin.qq.com/s?__biz=MzU0MzQ5MDA0Mw==&mid=2247493820&idx=2&sn=176897c44b23ba88760b190556752617)
==隔离级别与锁的关系==
1.  读未提交： 读取数据不加读锁，这样也就不会跟写锁冲突
2.  读已提交： 读操作加读锁，语句执行完立马释放。两条语句各自加、放。
3.  可重复读： 读操作加锁，事务执行完毕以后才释放锁。
4.  序列化：串行读读、读写、写读、写写

==锁粒度==
行级锁：mysql 中锁定粒度最细的一种锁，只对当前操作的行进行加锁。
表级锁：锁粒度最大的一种锁，当前操作的整张表加锁。
页级锁：粒度介于表级锁和行级锁之间，锁定相邻的一组记录。

==锁粒度取决于具体存储引擎==
MyISAM 采用表级锁(table-level locking)
InnoDB 支持行级锁(row-level locking)和表级锁，默认为行级锁。

==锁类别及实现==
共享锁：
1. 读锁，可同时加多个。
2. 一般通过使用版本号 vsersion机制或 CAS 算法实现
排他锁：
1. 写锁，只能加一个。
2. 使用数据库中的锁机制

==InnoDB 怎么实现==
1. 基于索引实现行锁： 
	1. select * from tab_with_index where id = 1 for update;
	2. for update 可以根据条件来完成行锁锁定，并且 ID 是有索引键的列，如果 ID 不是索引键那么 InnoDB 将完成表锁，并发将无从谈起
2. innodb锁算法
	1. Record lock：单个行记录上的锁  
	2. Gap lock：间隙锁，锁定一个范围，不包括记录本身  
	3. Next-key lock：record+gap 锁定一个范围，包含记录本身



[MySQL 有哪些锁？ | 小林coding](https://xiaolincoding.com/mysql/lock/mysql_lock.html)
==全局锁==
全库逻辑备份
`flush tables with read lock`，整个数据库都是只读状态。
备份怎么避免使用全局锁影响业务数据入库？

==表级锁==
MySQL 里面表级别的锁
1. 表锁
2. 元数据锁（MDL）
	1. 不需要显示使用，当对数据库进行操作时会自动加上
		1. 进行 crud 操作时，加的是 MDL 读锁
		2. 对表做结构变更时，加的是 MDL 写锁
3. 意向锁
	1. 意向锁的目的是为了快速判断表里是否有记录被加锁
	2. 
4. AUTO-INC 锁
	1. 

==行级锁==
	1. Record lock：单个行记录上的锁 
		1. 分读锁写锁
		2. 
	2. Gap lock：间隙锁，锁定一个范围，不包括记录本身  
		1. 只存在可重复读级别，为了解决可重复读隔离级别下幻读的现象
		2. 
	3. Next-key lock：record+gap 锁定一个范围，包含记录本身
		1. 既能保护该记录，又能阻止其他事务将新纪录插入到被保护记录前面的间隙中。

插入意向锁：
一个事务在插入一条记录的时候，需要判断插入位置是否已被其他事务加了间隙锁（next-key lock 也包含间隙锁）。
如果有的话，插入操作就会发生**阻塞**，直到拥有间隙锁的那个事务提交为止（释放间隙锁的时刻），在此期间会生成一个**插入意向锁**，表明有事务想在某个区间插入新记录，但是现在处于等待状态。

[MySQL 是怎么加锁的？ | 小林coding](https://xiaolincoding.com/mysql/lock/how_to_lock.html)
1. 什么情况下会加行级锁
	1. 锁定读
		1. `select ... lock in share mode;` 对读取的记录加共享锁 (S型锁)
		2. `select ... for update;` 对读取的记录加独占锁 (X型锁)
	2. update 和 delete 操作都会加行级锁，且锁的类型都是独占锁 (X型锁)。
2. 在不同的隔离级别下，行锁种类不同
	1. 读已提交级别下，只有记录锁
	2. 可重复读级别下
		1. 记录锁 Record Lock
		2. 间隙锁 Gap Lock
		3. 临键锁 Next-Key Lock
3. Record Lock
	1. 有共享锁和独占锁之分，只有S和S兼容
4. Gap Lock
	1. 只存在于可重复读隔离级别，目的是为了解决可重复读隔离级别下幻读的现象
	2. 表中有一个范围 id 为（3，5）间隙锁，那么其他事务就无法插入 id = 4 这条记录了，这样就有效的防止幻读现象的发生。
	3. 间隙锁虽然存在 X 型间隙锁和 S 型间隙锁，但是并没有什么区别，都是不允许插入数据
5. Next-Key Lock
	1. 是 Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身
	2. 表中有一个范围 id 为（3，5] 的 next-key lock，那么其他事务即不能插入 id = 4 记录，也不能修改和删除 id = 5 这条记录。
	3. 虽然相同范围的间隙锁是多个事务相互兼容的，但对于记录锁，我们是要考虑 X 型与 S 型关系，X 型的记录锁与 X 型的记录锁是冲突的
6. MySQL 是怎么加行级锁的？
	1. 加锁的对象是索引，加锁的基本单位是 next-key lock，它是由记录锁和间隙锁组合而成的，next-key lock 是前开后闭区间，而间隙锁是前开后开区间。
	2. 在能使用记录锁或者间隙锁就能避免幻读现象的场景下， next-key lock 就会退化成记录锁或间隙锁。
	3. 具体分析了
		1. 非唯一索引和主键索引的等值查询
		2. 非唯一索引和主键索引的范围查询
		3. 在执行 update、delete、select ... for update 等具有加锁性质的语句，一定要检查语句是否走了索引，如果是全表扫描的话，会对每一个索引加 next-key 锁，相当于把整个表锁住了




[MySQL增删改查都会用到什么锁? | 星辰大海](https://vincentruan.github.io/2020/02/12/MySQL%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E9%83%BD%E4%BC%9A%E7%94%A8%E5%88%B0%E4%BB%80%E4%B9%88%E9%94%81/)
==读（select）==
1. 一致性读/快照读
	1. 利用 MVCC 机制
2. 锁定读
	1. 加共享锁，其他事务可读不可写
	2. 加排他锁，其他事务不可读、不可写

==写（update、delete、insert）==

==delete==
1. 加锁
	1. 删除一条记录是先在索引的 B+树上获取该记录位置，然后在这个位置加 x 锁。
	2. 删除范围记录，在 B+tree 找到记录及记录之前的区间加 next-key 锁
2. 更改标识
	1. 先将 delete 的标识改为 1，等这块空间被复用

==update==
1. 对一条记录 update，假如这条记录存储空间没有变化，则在该记录直接更新
2. 假如发生了存储空间变化，则删除后再插入新的
具体细分为
1. 没有更新索引键值 且 没有空间变化，直接在索引的 B+tree 使用 x 锁来锁定 update 记录
2. 没有更新索引键值 但 空间变化了，会先删再插新记录。
	1. 先获取索引 B+tree 的 x 锁
	2. insert 过程使用隐式锁
3. 修改了索引键值，则要先 delete, 再 insert
	1. 加锁规则就和 delete 以及 insert 一样
注意点：
1. 除了第一种情况，都会加排他的 next-key 锁，来锁定记录和记录之前的范围。
2. update 的是主键的记录....
3. 如果在唯一索引上使用唯一的查询条件来进行update和delete操作，那么这个过程中只会对记录加锁。

==insert==
insert操作会用排它锁封锁被插入的索引记录，而不会封锁记录之前的范围。除此之外，会在插入区间加入插入意向锁


[线上发生Mysql死锁，你的排查思路？](https://blog.csdn.net/weiwosuoai/article/details/100032128)


[mysql的锁机制(读锁，写锁，表锁，行锁，悲观锁，乐观锁，间隙锁)](https://blog.csdn.net/qq_44766883/article/details/105879308)


[数据库的索引和锁到底是怎么回事](https://mp.weixin.qq.com/s?__biz=MzAxNjM2MTk0Ng==&mid=2247487905&idx=3&sn=f68de45bbd02aa09fb0b3140a231401a
1. 索引
2. 锁
	1. 对于 UPDATE、DELETE、INSERT 语句，InnoDB 会自动给涉及数据集加排他锁（X)
	2. InnoDB 行锁和表锁都支持
	3. InnoDB 只有通过索引条件检索数据才使用行级锁，否则，InnoDB 将使用表锁
		1. 也就是说，InnoDB 的行锁是基于索引的！
	4. 表锁
		1. 表读锁（Table Read Lock）
		2. 表写锁（Table Write Lock）
	5. 行锁
		1. 共享锁（S 锁）
		2. 排他锁（X 锁)
	6. 为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB 还有两种内部使用的意向锁（Intention Locks），这两种意向锁都是表锁：
		1. 意向共享锁（IS）
		2. 意向排他锁（IX）
	7. 意向锁也是数据库隐式帮我们做了，不需要程序员操心！
3. 事务的隔离级别就是通过锁的机制来实现，只不过隐藏了加锁细节
	1. MVCC (Multi-Version Concurrency Control)多版本并发控制，可以简单地认为：MVCC 就是行级锁的一个变种 (升级版)。
	2. 


[select......for update会锁表还是锁行。\_select 会加锁吗\_油锅里的猪的博客-CSDN博客](https://blog.csdn.net/qq_42956376/article/details/109544539)
1. select 查询语句是不会加锁的，但是 select ....... for update 除了有查询的作用外，还会加锁呢，而且它是[悲观锁](https://so.csdn.net/so/search?q=%E6%82%B2%E8%A7%82%E9%94%81&spm=1001.2101.3001.7020)。
2. 那么它加的是行锁还是表锁，这就要看是不是用了索引/主键。
3. 没用索引/主键的话就是表锁，否则就是是行锁。

##### next-key 

[next-key 锁的加锁规则其实挺复杂的，在一些场景下会退化成记录锁或间隙锁](https://mp.weixin.qq.com/s/i5QWx3QPZNkV51ghFbtXCw)
next-key lock 锁的是索引，而不是数据本身，所以如果 update 语句的 where 条件没有用到索引列，那么就会全表扫描，在一行行扫描的过程中，不仅给行加上了行锁，还给行两边的空隙也加上了间隙锁，相当于[锁住整个表](https://mp.weixin.qq.com/s/9R8ChusahrJvLGmUvHWBgA)，然后直到事务结束才会释放锁。
1. InnoDB 存储引擎的默认事务隔离级别是「可重复读」，但是在这个隔离级别下，在多个事务并发的时候，会出现幻读的问题，所谓的幻读是指在同一事务下，连续执行两次同样的查询语句，第二次的查询语句可能会返回之前不存在的行。
2. 因此 InnoDB 存储引擎自己实现了行锁，通过 next-key 锁（记录锁和间隙锁的组合）来锁住记录本身和记录之间的“间隙”，防止其他事务在这个记录之间插入新的记录，从而避免了幻读现象。
3. 当我们执行 update 语句时，实际上是会对记录加独占锁（X 锁）的，如果其他事务对持有独占锁的记录进行修改时是会被阻塞的。另外，这个锁并不是执行完 update 语句就会释放的，而是会等事务结束时才会释放。
4. 在 InnoDB 事务中，对记录加锁带基本单位是 next-key 锁，但是会因为一些条件会退化成间隙锁，或者记录锁。加锁的位置准确的说，锁是加在索引上的而非行上。
5. 比如，在 update 语句的 where 条件使用了唯一索引，那么 next-key 锁会退化成记录锁，也就是只会给一行记录加锁。
6. 在 update 语句的 where 条件没有使用索引，就会全表扫描，于是就会对所有记录加上 next-key 锁（记录锁 + 间隙锁），相当于把整个表锁住了。
7. **关键看这条语句在执行过程中，优化器最终选择的是索引扫描，还是全表扫描，如果走了全表扫描，就会对全表的记录加锁了**。
8. 可以打开 MySQL 里的 sql_safe_updates 参数，这样可以预防 update 操作时 where 条件没有带上索引列。
