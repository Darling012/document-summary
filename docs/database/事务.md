##### mysql、jdbc、mybatis、spring 中事务相关怎么联系的，边界在哪
2. [Spring事务_数据库连接和Java线程的关系](https://www.cnblogs.com/xfeiyun/p/15114072.html)
3. [多线程与数据库事务以及数据库连接之间的关系](https://cloud.tencent.com/developer/article/1861190)
# 事务
#### 为什么需要事务？事务解决了什么问题？事务是什么？
A向B转100，在数据库中分为两步，A-100,B+100。这就有可能
1. 操作过程出错，第二步未执行
2. 系统崩溃，丢失记录
3. 有并发情况，同时有向B转钱的

#### 事务怎么解决这些问题？
1. 故障恢复：日志恢复技术
2. 并发：并发控制技术

**定义:数据库事务是构成单一逻辑工作单元的操作集合**
1. 是多个数据库操作
2. 要么都执行，要么都不
3. 以上系统出现奔溃或并发依然成立

##### 并发下的数据异常情况
脏写：事务回滚了其他事务已提交的写
脏读：一个事务读取了其他事务未提交的数据
丢失更新：事务提交覆盖了其他事务已提交的写
不可重复读：一个事务在另一个事务提交数据前读了一次，提交后又读了一次，前后不一致
幻读：一个事务前后读取范围数据，中间其他事务改变了这个范围数据

不可重复读和幻读区别在于幻读针对多行数据，所以常出现在带条件的范围查询中。
不可重复读重点在于update和delete，而幻读的重点在于insert。
##### 事务的隔离级别
当串行化时，就不会出现并发问题。但为了提高处理能力，有所放宽隔离级别，也就会不同程度的出现并发问题。

1. 读未提交（READ UNCOMMITTED）
   1. 一个事务还没提交时，它做的变更会被其他事务看到。也就是一个事务可以读取另一个未提交的事务。
   2. 不加锁，可读取到事务中间状态，数据异常情况都会出现。
2. 读已提交（READ COMMITTED）（oracle默认的隔离级别）
   1. 一个事务提交以后，它做的变更才能被其他事务看到。也就是一个事务要等另一个事务提交后才能读取数据。
   2. 同一事务不同时刻读取到的数据值可能不一样，每次读都是一份快照，而不是一个事物一份，无法做到可重复读，也解决不了幻读。
3. 可重复读（REPEATABLE READ）(mysql默认的隔离级别)
   1. 一个事务执行过程中读到的数据，一直跟它启动时读到的数据一致。
   2. 可重复读 是针对 不可重复读 而言的，事务不会读取到其他事务对已有事务的修改。但是其他事务插入数据可以读到。
4. 串行化（SERIALIZABLE）
   1. 所有的读写操作都串行执行，不会有并发问题

在事务的 ACID 特性中:
1. 原子性和持久性事务本身层面性质，是为了要实现数据的可靠性保障，比如要做到宕机后的恢复，以及错误后的回滚。
2. 隔离性是指事务之前应该保持的关系，要管理多个并发读写请求的访问顺序，这种顺序包括串行或者是并行。
3. 原子性，隔离性，持久性的目的都是为了要做到一致性, 而对数据一致性的破坏主要来自两个方面
	1. 事务故障或系统故障
	2. 事务的并发执行
##### 数据库系统如何避免？
并发控制技术保证了事务的隔离性,使数据库的一致性状态不会因为 并发执行 的操作被破坏。
日志恢复技术保证了事务的原子性,使一致性状态不会因 事务或系统故障 被破坏。同时使已提交的对数据库的修改不会因系统崩溃而丢失,保证了事务的持久性。
##### 实现
1. 事务的原子性是通过 undo log 来实现的
2. 事务的持久性是通过 redo log 来实现的
3. 事务的隔离性是通过 (读写锁+MVCC)来实现的
4. 而事务的终极大 boss 一致性是通过原子性，持久性，隔离性来实现的

## InnoDBMysql 事务 ACID 特性的实现
[MySQL是如何实现ACID的](https://mp.weixin.qq.com/s/qLLd-2s57NmQ2UQUutQzzw)
[拨开云雾见天日：剖析单机事务原理](https://cloud.tencent.com/developer/article/1435926)
### 原子性(Atomicity)
#### 什么是原子性？
一个事务必须被视为不可分割的最小工作单位，一个事务中的所有操作要么全部成功提交，要么全部失败回滚，对于一个事务来说不可能只执行其中的部分操作，这就是事务的原子性。当事务无法成功执行的时候，需要将事务中已经执行过的语句全部回滚，使得数据库回归到最初未开始事务的状态。

##### 数据库怎么实现呢？
就是在发生错误或显示rollback时通过undo日志进行回滚，把数据还原成原先的样子。
##### undo log
![MySQL日志](MySQL日志.md#uodo%20log)
### 一致性(Consistency)
**事务追求的最终目标**，事务的执行结果必须使数据库从一个一致性状态到另一个一致性状态。不存在中间状态，事务A的中间数据其他事务看不到。

### 隔离性(Isolation)
并发执行的事务不会相互影响,其对数据库的影响和它们串行执行时一样。离性要求不同事务之间的影响是互不干扰的，一个事务的操作与其它事务是相互隔离的。
事务之间的隔离，通过锁机制实现。

### 持久性(Durability)
#### 什么是持久性？
事务一旦提交,其对数据库的更新就是持久的。任何事务或系统故障都不会导致数据丢失。
数据存贮在磁盘上，磁盘io消耗性能大，于是
##### InnoDB的缓冲池(Buffer Pool)
Buffer Pool中包含了磁盘数据页的映射，可以当做缓存来使用：
读数据：会首先从缓冲池中读取，如果缓冲池中没有，则从磁盘读取在放入缓冲池；
写数据：会首先写入缓冲池，缓冲池中的数据会定期同步到磁盘中；
但这就造成了宕机时，缓冲池数据可能未同步到磁盘。为了解决，于是
### 并发控制技术
并发读不会出现异常。多个请求中有读有写或者都是写就会出现问题。
#### 锁
用读写锁的组合来对读写请求进行控制，读写锁能做到读读并行，但做不到写读、写写并行。
1. 读锁 (共享锁)：可共享，多个读请求可共享一把锁，不会阻塞。
2. 写锁 (排他锁):  排斥所有获取锁请求，独占，阻塞，直到释放锁。

#### mvcc
目的：
通过数据多版本来做到读写分离。从而实现不加锁读进而做到读写并行
怎么实现？
通过在每行数据后保存两个隐藏列
1. 行的创建版本时间
2. 行的过期
InnoDB 实现MVCC，是通过`Read View+ Undo Log` 实现的
1. undo log: 记录某行数据的多个版本数据
2. Read view: 用来判断当前版本数据的可见性

[MVCC 这么理解](https://mp.weixin.qq.com/s/dMErouLlrte84Nmb97MkTQ)



## JDBC与Mybatis
1. [Mybatis3.3.x 技术内幕（三）：Mybatis 事务管理（将颠覆你心中目前对事务的理解）](https://my.oschina.net/zudajun/blog/666764)
### 事务的核心是  并发+锁

事务单元之间的happen-before关系:读写、写读、读读、写写。

如何在更快的完成事务单元之间的关系？
##### 排他锁
序列化读写： 写-》读-》写-》-》
##### 锁分离
事务 A 与事务 B 操作不同的数据，对不同的数据加锁，可以并行
##### 读写锁
1. 读读并行，一个事务内未commit之前多次读的都是最初的数据, 这就是可重复读及别。

[Innodb中的事务隔离级别和锁的关系](https://tech.meituan.com/2014/08/20/innodb-lock.html)
2. 读写并行，在数据库对当前读操作加锁时，来一个写操作，若是读锁不能升级成写锁，那么只能读读并行，读到不同的快照版本。
3. 如果可升级，那么就做到了读写、读读并行。但这会出现不可重复读，幻读情况。一个事务在读数据过程中，其他事务完成对数据更改，再次读就会出现不一致情况。这就是读已提交级别。
4. 不要读锁，就剩下写写并行了。

## reference
[数据库事务的概念及其实现原理](https://www.cnblogs.com/takumicx/p/9998844.html)
1. 为什么需要数据库事务
2. 什么是数据库事务
3. 事务如何解决问题
4. 事务的ACID特性以及实现原理
5. 常见的并发异常
	1. 脏写
	2. 丢失更新
	3. 脏读
	4. 不可重复读
	5. 幻读
6. 事务的隔离级别
7. 事务隔离性的实现
	1. 乐观并发控制和悲观并发控制
	2. 基于锁
	3. 基于时间戳
	4. 基于有效性检查
	5. 基于快照隔离
8. 为什么需要故障恢复技术
9. 
##### 隔离级别不同所带来的数据异常情况
[理解事务的4种隔离级别-腾讯云开发者社区-腾讯云](https://cloud.tencent.com/developer/article/1865041)
1. Read uncommitted
	1. 一个事务可以读取另一个未提交事务的数据。
	2. A向B支付100，但未提交，B读到了100，后A改100为50，也就是B读到了A未提交的数据，也就是脏读。
	3. Read committed，能解决脏读的问题
2. Read committed
	1. 一个事务要等另一个事务提交后才能读取数据。
	2. A事务读取到100，B事务对100进行更新操作，因为B事务未提交，所以A事务再读时还是100，读不到B事务修改的值，即避免了脏读。但当B提交后，A再读，就不是100了，也就出现了不可重复读。
	3. Repeatable read解决了不可重复读的问题
3. Repeatable read
	1. 在开始读取数据（事务开启）时，不再允许修改操作
	2. 就是A事务开始后，不允许其他事务进行修改操作。
	3. 不可重复读对应的是其他事务的修改操作，但不能解决幻读问题，幻读对应的是插入操作。
	4. 幻读就是A事务读取范围数据，B插入了新的记录，造成A前后读取不一致
	5. 串行化，解决了幻读问题
##### 为什么Read committed会出现不可重复读现象
[Read Committed 为什么不能防止不可重复读现象\_51CTO博客\_Read Committed](https://blog.51cto.com/u_14201949/2832632)
1. 客户端A开启事务读取account表，money为1000，不提交事务
2. 客户端B开启事务修改money为2000，不提交事务
3. 两个客户端隔离级别都为Read Committed，当A再次读取时，因为B的事务未提交，所以读到的还是1000，也就避免了脏读
	1. **不同的客户端设置不同的隔离级别是啥意思？隔离级别不是针对MySQL服务器说的吗？**
4. 当B提交事务后，A再次读，会读到2000也就跟开始不一致，也就出现了不可重复读
5. 常规想法不应该是读写锁互斥吗？为什么A在加了读锁后，B还能写？
	1. mysql中读提交和可重复读是通过MVCC实现的，而不是通过加读写锁。
	2. 因为加读写锁的话只有读读可以并行，读写、写读、写写都不能并发效率太低。
	3. 使用MVCC实现读提交和可重复读，就可以在读的时候不加锁，读读、读写、写读都可并行，只在写写阻塞
	4. MVCC会记录每个读操作行数据的历史版本
	5. 可重复读，在事务第一次读时的版本，在整个事务过程中读取的都是这个版本
		1. **既然每次读取的都是一样的快照，不就没有幻读问题了吗？**
	6. 读提交，每次读都是读的最新版本，所以可能存在多次读取不一致，即不可重复度。

##### 为什么Repeatable read会出现幻读
[可重复读隔离下为什么会产生幻读？](https://blog.csdn.net/qq_42799615/article/details/110942949) 


[既然MySQL中InnoDB使用MVCC，为什么REPEATABLE-READ不能消除幻读？](  https://www.zhihu.com/question/334408495/answer/2135229572 )
要讨论「可重复读」隔离级别的幻读现象，是要建立在「当前读」的情况下，而不是快照读！
1. 普通的查询是快照读, 而其他update、insert、delete、select ... for update都是当前读
2. 假如当前读不加锁，就会出现幻读。读的是最新的记录，中间别的事务插入数据后，就会前后不一致。
3. 所以，innodb为了解决「可重复读」使用「当前读」情况下的幻读问题，引入了 `next-key` 锁（记录锁+间隙锁）
	1. 记录锁，锁的是记录本身
	2. 间隙锁，锁的是两个值之间的空隙，防止插入，造成幻读
4. ![next-key ](Mysql锁.md#next-key)




[MySQL RR 与 幻读问题（实验 + 案例）](https://mp.weixin.qq.com/s/givYGqGSbHc3wTfglSpZYA)

