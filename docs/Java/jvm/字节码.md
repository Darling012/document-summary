## 字节码
### 字节码结构
1. [Java字节码增强](https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&mid=2653199680&idx=2&sn=6024794b54781b283f3cd1b358220088)
2. [Java字节码](https://www.jianshu.com/p/252f381a6bc4)
3. [轻松看懂Java字节码 - 掘金](https://juejin.cn/post/6844903588716609543)
4. [字节码增强技术探索 - 美团技术团队](https://tech.meituan.com/2019/09/05/java-bytecode-enhancement.html)
5. [Java编译后产生class文件的命名规则_千寻～的博客-CSDN博客](https://blog.csdn.net/u011630575/article/details/75669603)
6. [Arthas 实现原理 ]( https://www.51cto.com/article/709823.html )
[看了这篇【JIT编译器】，你也能说你会java性能优化了！ - 掘金](https://juejin.cn/post/6844904154645659656)
### 字节码增强
##### Instrument
[Instrumentation](https://mp.weixin.qq.com/s?__biz=MzIzMzgxOTQ5NA==&mid=2247487814&idx=1&sn=f702e7324cf02fc5b52619ac08166c11)
Instrument 就是「针对已有的类修改其字节码来增强其逻辑，从开发者的角度可以理解为 JVM 层面的 AOP 编程」。开源的很多 APM(Application Performance Monitor) 框架如 SkyWalking、PinPoint 等都是通过java.lang.instrument包提供的字节码增强功能来实现的，大部分情况下 我们都是使用 Instrument 字节码插桩的功能
##### ASM

字节码增强应用
热部署、[链路探测](https://mp.weixin.qq.com/s/lfIGjddkFVlhDZH8uHYdWA)、arthas 这种动态改变



## JVM 如何执行代码

1. [JVM 栈帧，静态、动态分派以及虚方法表 - 掘金](https://juejin.cn/post/7004281096074428423)
2. [虚方法表与动态分派机制详解 - cexo - 博客园](https://www.cnblogs.com/webor2006/p/9814768.html)



[hashCode 和对象的内存地址有什么关系](https://juejin.cn/post/6971946031764209678)
1. ` java.lang.Object@6659c656`
	1. `@` 后面的只是对象的 16 进制展示的 hashcode  值
2. JVM 提供了 6 种 hashcode 的生成逻辑，可以通过 jvm 启动参数来控制
	1. `hashCode == 0`，使用的一种 Park-Miller RNG 的随机数生成策略。不过需要注意的是……这个随机算法在高并发的时候会出现自旋等待
	2. `hashCode == 1`，真的是对象的内存地址了，直接获取对象的 `intptr_t` 类型指针
	3. `hashCode == 2`，固定返回 1，应该是用于内部的测试场景
	4. `hashCode == 3`，所有对象的 hashCode 都使用这一个自增变量
	5. `hashCode == 4`，这里和第 1 种算法其实区别不大，都是返回对象地址，只是第 1 种算法是一个变体。
	6. `hashCode == 5`，最后一种，也是默认的生成算法，hashCode 配置不等于 0/1/2/3/4 时使用该算法
		1. 这里是通过当前状态值进行异或（XOR）运算得到的一个 hash 值，相比前面的自增算法和随机算法来说效率更高，但重复率应该也会相对增高，不过 hashCode 重复又有什么关系呢…… ​
		2. 本来 jvm 就不保证这个值一定不重复，像 HashMap 里的链地址法就是解决 hash 冲突用的



## 双亲委派 classloader

[JVM类加载机制](https://mp.weixin.qq.com/s?__biz=MzU0OTk3ODQ3Ng==&mid=2247485642&idx=1&sn=14542b61ed71e94732f71ab4956049d4)


[Class.forName 和 ClassLoader 有什么区别？](https://mp.weixin.qq.com/s?__biz=MzIzMzgxOTQ5NA==&mid=2247488216&idx=2&sn=221b30554352cc71c3eeaacd2f22a067)
1. 在 java 中 Class.forName () 和 ClassLoader 都可以对类进行加载。
2. ClassLoader 就是遵循双亲委派模型最终调用启动类加载器的类加载器，实现的功能是“通过一个类的全限定名来获取描述此类的二进制字节流”，获取到二进制流后放到 JVM 中。
3. Class.forName () 方法实际上也是调用的 CLassLoader 来实现的。
4. Class.forName 加载类是将类进了初始化，而 ClassLoader 的 loadClass 并没有对类进行初始化，只是把类加载到了虚拟机中。

5. [什么地方违反了双亲委派模型](https://mp.weixin.qq.com/s?__biz=MzAxOTQxOTc5NQ==&mid=2650500033&idx=1&sn=6c1867078747dc4f428bb8bd8f0ef495)
6. 
7. [不重启 JVM，替换掉已经加载的类](https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487211&idx=1&sn=6c690228f7a5f430c3c3d60f929bbc17&)
8. 
9. [双亲委派](https://mp.weixin.qq.com/s/Q0MqcvbeI7gAcJH5ZaQWgA)



## 编译原理
[为什么编译原理被称为龙书？ - 程序员cxuan - 博客园](https://www.cnblogs.com/cxuanBlog/p/13327003.html)
[编译原理之美\_编译\_编译器-极客时间](https://time.geekbang.org/column/intro/219)
[聊聊编译原理（一） - 词法分析 - 御坂研究所](https://www.nosuchfield.com/2017/07/16/Talk-about-compilation-principles-1/)