# 分布式事务

[事务、mysql事务、orm事务、spring事务](事务.md#事务) 

## 两种思维
##### 2PC
1. 有回滚概念，做到一半做不下去可以回撤。
2. 方案
	1. 数据库 2PC-XA
	2. TCC
	3. AT、XA、TCC
3. 解决的问题场景
	1. 并发没有那么高
	2. 业务要求接入简单，标准化开发，开发门槛低

##### 1PC
1. 没有回撤机会，一旦做了，就硬着做完，做不完就不断重试直到成功或达到最大重试次数人工介入
2. 方案
	1. 异步：最终一致性
	2. 同步：事务状态表 + 事务补偿
	3. 同步：同步双写 + 异步对账
	4. 妥协方案：同步双写 + 各种补偿
3. 解决的问题场景
	1. 高并发
	2. 开发门槛高，自己维护各种数据状态，做异步对账，补齐。
	3. 第三个方案实践中应用的尤其多，如缓存和数据库一致性场景
---
## 方案
1. 最终一致性
	1. 业务方自己实现
	2. 消息中间件的事务消息改进
2. tcc
	1. Tcc 自身
	2. 自己实现类 TCC：事务状态表 + 补偿
3. 弱一致性
	1. 对账
	2. 基于状态的事后补偿
	3. 重试 + 回滚 + 报警 + 人工修复 

#### 2PC
两个角色：
1. 协调者
2. 参与者
两个阶段：
1. 准备阶段：协调者向每个参与者发起询问，要执行一个事务，参与者可能回复 yes、no 或者超时
2. 提交阶段：
	1. 若所有参与者回复的都是 yes，则协调者向各个参与者发起提交事务 commit 操作，各个参与者执行后发送 ack 消息。
	2. 若有参与者回复 no 或者超时，则协调者向各个参与者发起回滚 rollback 操作，各个参与者执行后发送 ack 消息。
3. 实现：
	1. 2pcxa 规范，主流数据库都实现了 xa 协议，mysql 提供了 <font color=#C32E94>xa_recover</font> 原语用于查询 2pc 失败的悬停事务。
4. 问题：
	1. 性能问题：准备阶段协调者要等所有参与者都返回消息
	2. 准备阶段后，协调者宕机，所有参与者接收不到 commit、rallback 指令，处于悬停事务状态，要自己加 <font color=#C32E94>xa_recover</font> 做事务补偿
	3. 某个参与者不能正常回复 ack 消息，其他参与者不知道如何处理
	4. 2pc 主要用于实现了 xa 协议的数据库之间，而我们场景大多是微服务的服务之间，而不是一个服务连两个数据库
#### 3PC
引入超时机制以期解决 2PC 问题。

场景：
A、B 两个服务，分别对应 DB1, DB2, A 向 B 转钱，A 减钱，B 加钱，如何保证两个操作在两个系统中同时成功？
#### 最终一致性
问题：
1. A 更新 DB1 与向发送消息是两个操作，如何保证原子性。
2. 网络两将军问题：A 收不到 B 返回消息情况，不能确实是收到了没回复成功还是没收到 A 发送的消息。
3. A 为了确保 B 收到消息，多次重复发送，B 如何处理重复数据
4. B 在处理某条数据时宕机如何不丢失这条数据
##### 业务方自己实现：
1. A 加消息表，减钱操作与增加消息在一个事务里，保证消息在发送方不丢失，再增加一个服务不断轮询消息表，向 B 发送消息。失败了重复发，直到收到确认收到消息回复。
2. B 消费消息前对消息判重，保证在接收方不重复消费同一条数据。

###### 加入消息中间件情况下
1. 保证消息在发送方不丢失
	1. A 加消息表，减钱操作与增加消息在一个事务里，，再增加一个服务不断轮询消息表，向消息中间件发送消息。失败了重复发，直到收到确认收到消息回复。
2. B  处理过程中宕机，丢失消费
	1. 通过消息中间件 ack 机制。B 在处理结束后发送 ack 消息，凡是消息中间件没有收到 ack 消息的数据都会再次推送。
3. B 重复消费
	1. B 增加判重表或者根据 B 自身业务数据判断要不要消费这条数据
##### 基于事务消息
为了不跟业务逻辑耦合，通过 rocketmq 的事务消息实现

将消息发送拆为两个阶段：
1. prepare 阶段
2. confirm 阶段
具体步骤为
1. A 调用 prepare 接口，向中间件发送消息，中间件不会向 B 发送而是暂存。
2. A 执行扣钱操作更新数据库
3. A 调用 confirm 接口，中间件推送消息。
步骤 2 可能失败或超时，3 不执行；步骤 3 失败或超时。
那么：
rocketmq 会扫描预发送但还没确认的消息回调给 A, 让 A 决定发出去还是取消。

对比以上两个方案：
1. 事务消息只是省略了业务方自己实现的扫描消息表步骤
2. 事务消息方案 A 也需要有个表记录消息状态以供中间件询问某条数据作何处理时决断。
3. 没有改善 B 面临的问题。

#### TCC
1. 应用层面的 2PC，try、confirm、cancel 缩写。confirm 对应 2PC 的 commit，cancel 对应 rollback。
2. TCC 怎么解决 2PC 的协调者宕机和某个参与者不回复时问题？
	1. TCC 内部不断重试，无论是 confirm 还是 cancel，这就要求所对应的操作都是幂等的。
3. 怎么保证 confirm 和 cancel 都是幂等操作？
	1. 在 try 阶段，做资源检查和锁定资源，保证业务操作的前置条件都得到满足。

#### 业务方自己实现 TCC：事务状态表 + 事务补偿
事务状态表提供全局事务 ID、业务步骤和事务状态。
判断事务状态不是最终状态就不断重试。全局事务 ID 保证幂等操作（不理解如何做）。

#### 同步双写（多写） + 异步对账
扩展上个方案，不仅事务有状态，数据也有状态。从结果反推过程出现的问题，然后做补偿，也就是对账。



##### 总结
1. 最终一致性方案是一种异步方法，数据有一定延迟
2. TCC 是同步方法，性能损耗较大
3. 事务状态表类 TCC 也是同步
4. 对账是事后方法


#### 阿里 Seata 框架
提供了 AT、TCC、XA 模式，本质上都是 2PC
##### AT


##### reference
1. [分布式事务——概念简介和基础理论](https://mp.weixin.qq.com/s?__biz=Mzg3MjA4MTExMw==&mid=2247491309&idx=2&sn=7ca96c1335b307fd7f6e76b8304735ea)
2. [谈谈对分布式事务的一点理解和解决方案](https://mp.weixin.qq.com/s?__biz=MzU2MTI4MjI0MQ==&mid=2247491760&idx=2&sn=665c86559978aec2d5cf02379ca0c68f)
3. [基于本地消息表的分布式事务解决方案总结](https://mp.weixin.qq.com/s?__biz=MzAwMDczMjMwOQ==&mid=2247483682&idx=1&sn=e6a6553a9db23591b122ae883e770c87)
4. [分布式事务之Spring/JPA/JMS事务（二）](https://juejin.cn/post/6844903665656922126#heading-6)
5. [让我们聊一聊分布式事务](https://chenmingyu.top/distributed-transaction/)
6. [分布式事务可能是个伪概念](https://www.jdon.com/artichect/dtransaction.html)
7. [微服务下分布式事务模式的详细对比](https://mp.weixin.qq.com/s/rg_clDE6HO2SKZpq9tOqQA)
8. [分布式事务](https://mp.weixin.qq.com/s?__biz=MzU0OTk3ODQ3Ng==&mid=2247488500&idx=1&sn=fe6a0e37ae8ede9d65fd8ac2423cd07f)
9. 

中间件
1. [京东数科强一致、高性能分布式事务中间件 JDTX](https://www.infoq.cn/article/BAXzcfjRTcgmKisa7JHm?from=groupmessage&isappinstalled=0)
2. [金融级柔性分布式事务解决方案](https://github.com/dromara/hmily/blob/master/README_CN.md)
3. [Page not found · GitHub · GitHub](https://github.com/shuaiqiyu/hmily)