# 跨域
跨域是浏览器限制同源策略，让浏览器收到的响应都来自一个服务器的端口就不会有跨域问题。

[简单聊聊为什么会有同源策略和跨域问题 - 掘金](https://juejin.cn/post/6844904093417209864)
1. 主要限制 js 的能力

[Cors跨域(一)：深入理解跨域请求概念及其根因](https://mp.weixin.qq.com/s/dynx7wrSINYFKZgGPcD3zQ)
1. 什么是跨域
	1. 浏览器从一个域名的网页去请求另一个域名的资源时，域名、端口、协议任一不同，都是跨域。
	2. 在前后端分离的模式下，前后端的域名是不一致的，此时就会发生跨域访问问题。在请求的过程中我们要想回去数据一般都是post/get请求，所以跨域问题出现。
2. 请求头
	1. Host：域名+端口，要访问的地址
	2. Referer： 协议+域名+端口+参数，当前请求的来源页面地址
	3. Origin：来自哪里（跨域）。协议+域名+端口。用于 Cors 请求和同域 post 请求。
3. 浏览器同源策略
	1. 浏览器展示的内容来自不同服务器（黑客），所以要限制一个
4. 怎么才算同源
	1. 协议+IP+端口，三者都需相同
5. 不受同源策略的网络访问
	1. 浏览器自己是可以发起跨域请求的（比如 a 标签、img 标签、form 表单等），但是 Javascript 是不能去跨域获取资源（如 ajax）
6. Cors 的工作原理
	1. 若浏览器发送的是跨域请求，则在请求头携带 `Origin` 表明请求来自哪里
	2. 服务器根据传过来的 `Origin` 设置响应头 `Access-Control-Allow-Origin`
	3. 浏览器提取响应头 `Access-Control-Allow-Origin`，根据其值判断接收响应内容还是拒绝。
7. 针对响应头是否暴露给前端的控制
	1. `Access-Control-Expose-Headers`
	2.  6 个响应头外的前端不可见，包括 js
	3. 但是，这个控制对简单请求无效
8. 什么是简单请求
	1. 服务器对请求的处理不会导致自己资源的改变
9. **非简单请求可能对服务端资源改变，因此 Cors 规定浏览器在发出此类请求之前必须有一个“预检（Preflight）”机制**，这也就是我们熟悉的 `OPTIONS` 请求。
10. 预检请求主要将一些凭证、授权信息放在请求头里交给服务器做决策。
	1. Access-Control-Request-Method：真正请求的方法
	2. Access-Control-Request-Headers：真正请求的自定义请求头（若没有自定义的就是空呗）
11. 服务端收到请求后，根据其值做逻辑决策，返回 200 或者 400、403。成功的话设置响应头
	1. Access-Control-Allow-Origin
	2. Access-Control-Expose-Headers
	3. Access-Control-Allow-Methods：允许实际请求的 Http 方法
	4. Access-Control-Allow-Headers：允许实际请求的请求头
	5. Access-Control-Max-Age：允许浏览器缓存此结果多久，单位：秒。有了缓存，以后就不用每次请求都发送预检请求啦
12. 浏览器根据预检请求响应做逻辑处理
	1. 
## 同源策略
[AJAX 与跨域通信（一）：AJAX 与同源策略-腾讯云开发者社区-腾讯云](https://cloud.tencent.com/developer/article/1536497)
1. 为什么同源策略要禁止不同源之间进行这些操作呢？
2. 跨域请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了 。



## options 请求（预检请求、简单请求）

对那些可能对服务器数据产生副作用的 HTTP 请求方法（特别是[`GET`]( https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTTP%2FMethods%2FGET " https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/GET" )以外的 HTTP 请求，或者搭配某些 MIME 类型的[`POST`]( https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTTP%2FMethods%2FPOST " https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/POST" )请求），浏览器必须首先使用[`OPTIONS`]( https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTTP%2FMethods%2FOPTIONS " https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/OPTIONS" )方法发起一个预检请求（preflight request），从而获知服务端是否允许该跨域请求。服务器确认允许之后，才发起实际的 HTTP 请求。在预检请求的返回中，服务器端也可以通知客户端，是否需要携带身份凭证（包括[Cookies]( https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTTP%2FCookies " https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies" )和 HTTP 认证相关数据）


[对CORS OPTIONS预检请求的一些思考 - 知乎](https://zhuanlan.zhihu.com/p/341540880)
1. 浏览器最基本的安全规范-同源策略。所谓同源是指域名、协议、端口相同。不同源的浏览器脚本 (javascript、ActionScript、canvas)在没有明确授权的情况下，**不能读写对方的资源**。
2. CORS 就是 w 3 c 和浏览器厂商为解决跨域资源共享问题而推出的标准方案：**它允许浏览器向跨源服务器发出脚本请求**，CORS 需要浏览器和服务器同时支持，它的通信过程都是浏览器自动完成的，不需要用户参与。
3. 当前端使用脚本请求一个跨域资源时，如果是**非简单请求** (会写服务器)，浏览器会自动帮你先发出一个 OPTIONS 查询请求，称为预检 (cors-preflight-request)，**作用是询问服务器, 当前网页所在的域名是否在服务器的许可名单之中**，以及可以使用那些 HTTP 动词和头信息字段。 只有得到肯定答复，浏览器才会发生正式的 XHR 请求。

[跨域请求到底会不会被服务器执行 - 掘金](https://juejin.cn/post/7084034404321853453)
- 简单请求：不管是否跨域，只要发出去了，一定会到达服务端并被执行，浏览器只会隐藏返回值（拦截响应）
- 复杂请求：先发预检，预检不会真正执行业务逻辑，预检通过后才会发送真正请求并在服务端被执行
## 应用

[项目中跨域解决方式：HttpClient、注解、网关\_远走与梦游的博客-CSDN博客](https://blog.csdn.net/weixin_52210557/article/details/122803085)
