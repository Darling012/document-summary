# 低代码
1. 什么是低代码
2. 低代码解决了什么
3. 能帮助我们做什么
4. 我们能做哪些
低代码是什么？
-------
按[维基百科](https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Low-code_development_platform)的说法，低代码这个称呼是 Forrester 在 2014 年提出的，指那些用可视化方式创建应用的平台，特点是代码量比传统开发少得多，甚至无代码，所以能显著提升开发效率。
#### Wikipedia 定义
![](https://ucc.alicdn.com/pic/developer-ecology/c7810cec8fbf4fb691da4e8a29612017.png)
从 Wiki 的这段定义中，我们可以提炼出几个关键信息：
   • 低代码开发平台（LCDP）本身也是一种软件，它为开发者提供了一个创建应用软件的开发环境。看到 “开发环境” 几个字是不是很亲切？对于程序员而言，低代码开发平台的性质与 IDEA、VS 等代码 IDE（集成开发环境）几乎一样，都是服务于开发者的生产力工具。
   • 与传统代码 IDE 不同的是，低代码开发平台提供的是更高维和易用的可视化 IDE。大多数情况下，开发者并不需要使用传统的手写代码方式进行编程，而是可以通过图形化拖拽、参数配置等更高效的方式完成开发工作。

#### Forrester 定义
顺着 Wiki 的描述还能发现，原来 “Low-Code” 一词早在 2014 年就由 Forrester 提出了，它对低代码开发平台的始祖级定义是这样的：  
![](https://ucc.alicdn.com/pic/developer-ecology/1636f2c615c1493fb817d30d5d0081a4.png)
相比 Wiki 的版本，这个定义更偏向于阐明低代码所带来的核心价值：
 • 低代码开发平台能够实现业务应用的快速交付。也就是说，不只是像传统开发平台一样 “能” 开发应用而已，低代码开发平台的重点是开发应用更“快”。更重要的是，这个快的程度是颠覆性的：根据 Forrester 在 2016 年的调研，大部分公司反馈低代码平台帮助他们把开发效率提升了 5-10 倍。而且我们有理由相信，随着低代码技术、产品和行业的不断成熟，这个提升倍数还能继续上涨。
 • 低代码开发平台能够降低业务应用的开发成本。一方面，低代码开发在软件全生命周期流程上的投入都要更低（代码编写更少、环境设置和部署成本也更简单）；另一方面，低代码开发还显著降低了开发人员的使用门槛，非专业开发者经过简单的 IT 基础培训就能快速上岗，既能充分调动和利用企业现有的各方面人力资源，也能大幅降低对昂贵专业开发者资源的依赖。

低代码究竟能解决什么问题？
-------------
要回答这个问题，首先按《人月神话》里的说法将软件开发进行分类：
> 所有软件活动包括：  
> 根本任务 -- 打造构成抽象软件实体的复杂概念结构。  
> 次要任务 -- 使用编程语言表达这些抽象实体，在空间和时间限制内将它们映射成机器语言。
「根本任务」指什么？举个例子，比如要实现一款发工资的软件，里面涉及到如何计算所得税，那就得实现个人所得税的计算方法，用什么语言实现这个算法属于「次要任务」，而这个算法本身属于「根本任务」，无论用什么方式实现，你都不可能降低这个算法复杂度，比如个人所得税有 7 个层级，那就一定在某个地方有 7 个 if 语句。
「根本任务」无法解决，因为它就是需求本身，唯一解决办法是砍需求。
低代码平台主要解决的是「次要任务」，用更简化的方式来实现同样的功能，低代码平台解决不了「根本任务」，图形化编程只适合特定场景，用它来做控制流还不如写代码。对于企业内部应用，低代码可以显著提升效率，但效率提升带来的不是人员减少，而是需求增多。
根据《人月神话》作者 Fred Brooks 的划分，软件开发的复杂度可以划分为本质复杂度（Essential complexity ）和偶然复杂度（Accidental complexity）。前者是解决问题时固有的最小复杂度，跟你用什么样的工具、经验是否丰富、架构好不好等都无关，而后者就是除此之外在实际开发过程中引入的复杂度。通常来说，本质复杂度与业务要解决的特定问题域强相关，因此这里我把它称为更好理解的 “业务复杂度”；这部分复杂度不是任何开发方法或工具能解决的，包括低代码。而偶然复杂度一般与开发阶段的技术细节强相关，因此我也相应把它称为 “技术复杂度”；而这一部分复杂度，恰好就是低代码所擅长且适合解决的。
## 低代码平台适合用在什么地方？
企业应用领域的 LCAP 到底取代的是什么呢？一句话 —— 那些模式高度一致的企业中后台应用。形象一点说，就是长这个样子的应用。无论 CRM，ERP，还是 ERP，MES，这些软件门类都是属于企业中后台应用，它们都是围绕关系数据库而建立数据管理和工作流程。实际上，企业应用中90%以上的应用都是这个模型，业内称为 CRUD（数据增删查改）应用。正是因为模式上的一致性，让我们得以有机会抽象出这类应用构建所需要的基本要素，并且将这些要素的颗粒度充分提高，灵活组合，得以满足千变万化的具体场景。

> 女票是 SAP 实施，我实习时开发过 ERP。我模糊的理解上，隐约感觉到目前的低代码介于两者之间。SAP 是管理模式，是梳理流程。而 ERP 虽然也提供了流程，但根本还是人治，ERP 辅助。而低代码，apaas 这种模式，隐约觉得就是把流程掰碎了，然后人为组装。


## 已有的低代码平台
### 非Java
[ASP.NET | 适用于 .NET 的开源 Web 框架](https://dotnet.microsoft.com/zh-cn/apps/aspnet)
### Java
1. [简道云](https://www.jiandaoyun.com/index/customer_case)
2. [奥哲](https://www.authine.com/customer/)
3. [氚云](https://h3yun.com/index.php?g=Chuanyun&m=Case&a=index)
4. [易搭](https://yida.alibaba-inc.com/home/)
   ​	两个特点
   1. ERP、CRM
   2. 定制化服务
5. [jeecg](http://www.jeecg.com/)
6. [diboot](https://gitee.com/dibo_software/diboot)
7. [爱速搭](https://suda.baidu.com/)
> 单表的增删改查
>
> 前端单页的增删改查
8. 大屏
低代码的形式是“可视化编程”，核心是“复用”。
1. 在线 IDE 和编辑器，界面方面虽然有可视化设计，但需要二次开发才能用。
2. 提供一站式开发平台，提供了持续集成、部署和运维等功能，包含开发全流程。
3. 简化前端开发，界面方面可以做到不用写 JavaScript。
4. 简化后端开发，可以在线设计数据结构，并实现增删改查功能。
5. 彻底简化前后端开发，甚至变成无代码平台，什么都可视化编辑，易用性好，但牺牲了灵活性，这里面有很多子分类，比如 BPM、OA 系统、APP 开发等。
6. 围绕某个成熟产品扩展功能，比如 CRM、ERP 之类的产品，为了满足定制需求，提供定制开发功能。
> 康威定律："设计系统的架构受制于产生这些设计的组织的沟通结构。" ——M. Conway
比如公司内有两个独立的小组，那整个系统设计肯定会划分出两个独立的模块，相互之间有明确的界限，这也影响了对于低代码平台实现方式的选择。咱们前后端分离，可能就要弄两套。
如果是前端团队，一般会选第 1 种形式，很少考虑第 3 种，因为团队成员都会 JavaScript，没必要弄个不用写 JavaScript 的产品，更不会考虑第 4 种，因为不负责后端开发。
如果后端的团队，就会选择第 4 种，因为只负责后端开发。
如果是大公司内的工程团队，因为职责是负责开发环境，所以会选择第 2 种形式，但这种形式一般有很多定制功能，并且依赖公司内部基础设施，导致只能在内部使用。
如果是创业公司，往往会选择第 5 种形式，面向外部当然是前后端都封装起来更简单，但可能过于追求「无代码」，导致虽然用起来简单，却失去了灵活性，只适合简单应用。
如果公司本身有成熟产品了，自然是选择第 6 种方式，围绕这个产品来扩展更有优势。
因此下次在了解一款低代码产品前，先了解它背后是什么团队，擅长做什么，团队背景将在很大程度上决定这款产品的侧重点。

### 低代码之前的 Pro Code
问题：
1. 同一功能，把所有代码都码上去
2. 个人写代码逻辑不同，有差异
3. 后期修改，麻烦且出bug几率增大
4. 部门协作，流程上出现各种问题
优势：
1. 灵活
2. 更清晰实现需求
3. 更快的版本迭代、更高效的平台迁移

### Low Code、No Code
可视化编程：
1. 无代码 全部拖拉拽 点点点
2. 低代码 写部分代码
优势：
1. 少写代码
2. 上手难度低，代码编写能力低的也
问题：
1. 业务理解，更高层次的抽象
2. 不够细节，通用性需求，灵活性低
3. 能力弱，能做出什么取决于框架本身能力
4. 开发者不够友好，对开发者来说是黑盒，遇到bug、性能问题不好排查，依赖代码平台生成，对自身成长不大
Pro Code、Low Code、No Code给不同⼈使⽤的，解决着不同场景的问题 之间不是替代消灭关系，⽽是互补加强关系。

### 判断、引入及选择
首先，我们如何判断自己是不是适合可视化呢？
分为使用和研发两种情况。
> 1. 如果是使⽤的话，绝⼤部分都是适合的，“可视化”本就是个提效⼯具。
> 2. 如果是研发这类⼯具，不现实。
考虑好前面引入的情况之后，再看下，如果我们是选择研发这类工具的话，有那些难点呢？
> 2. 低代码⼯具研发周期较⻓，对团队能力要求高。无论技术还是业务。还是公司能否支持。
> 3. 另外研发低代码⼯具除了依赖技术底蕴外，更需强⼤过硬的产品思维，对业务非常非常熟悉。
如果直接使用的话，再去考虑可视化平台的选择。

### 对于我们来说
吸收哪些？要不要用？值不值得投入？
[jeecg](http://www.jeecg.com/)

jeecg相比起厂商的低代码平台，更严格的来说就是个快速开发脚手架。好多公司应该都有这样一个脚手架，满足基本功能的复用，简单增删改查的代码生成。这并不新鲜。对于我们来说，我们并不缺开发人员，所以对于我们来说更多的要提效，减少不必要的重复性工作。假若我们自建一个更高效的拖拉拽平台，这需要我们业务固化且对业务理解透彻，能有高层次抽象。目前对于我们济南研究院来说，环境并不成熟。所以，我们能做的，还是把平日工作中需要复制粘贴的代码，给统一，自动化。
那么说到这，我们要做的就跟市场上的低代码大相径庭了。我们其实就是弄个合适的脚手架。
脚手架：
前后端框架的完备保证：
1. 后续开发只需关注业务
2. 各项目统一
前端
1. 单页面的增删改查，后端的连表与前端没关系
2. 大屏报表
后端
1. 后端增删改查模板，单表多表
2. 组件、工具类
对于我们来说，算法那边不在考虑范围内。然后前端，前端目前需求大概三类，基础框架、管理页面、数据分析页面。后端主要是基础框架、信息管理类逻辑、业务逻辑、中间件工具类。前后端的基础框架解决的都是各个项目都能用到的需求、技术点还有就是前后端统一的交互。诸如登录、交互数据格式、状态码，前端的国际化、各种组件弹窗、统一的交互逻辑，后端的数据库、oauth2等。前端的管理页面对应后端的信息管理类，也就是增删改查。这种需求，前端只需要根据后端提供的pojo展现，前端需要统一的就是交互，数据列表的展示，单条信息的增删改查，多条的删。这些只有字段的不同，其他都是固定的。前端麻烦的点可能在于一些下拉列表或者多级树等组件的生成上。然后后端的增删改查大部分代码都一样，区别在于业务上，比如级联删除，增改部分字段全表的唯一性验证等。前端的数分析页面，驾驶舱，各种图的展示数据分析。因为咱们有摄像头硬件，所以驾驶舱可能有差异。然后数据分析类的大屏，这块可以做成工具，直接配数据库，直接抽取。最后是后端的业务逻辑、中间件工具类，业务逻辑没法复用，各个项目都不一样，比如火灾的预警信息聚合逻辑，其他项目可能就没有，这是必须要写的。中间件工具类是可以复用的，工具类一般跟项目业务都无关，中间件呢 ，无论是引入封装还是开发都是提供出API，直接复用就可。比如websocket，构建为一个服务后，前后端统一，这样后续的项目都后端直接掉服务，前端直接引模块就可以了。
我们现在其实最需要做的是统一。前端可能现在是复制页面，后端是自己用不同工具生成。虽然都大差不差，但是总有细微差异，比如我习惯把 Pojo 放这层而你放下一层，这样我看你代码就需要从头捋逻辑。假如我们统一了，大家都按一个规范来，看不出个人的代码风格，这样接手别人代码会极容易上手。这需要加强 code review，大家选出最好的解决方式，更优雅的代码结构，然后大家统一遵守。


后端生成控制类Demo：
```java
/**
 * ${comments}
 *
 * @author ${author}
 * @date ${datetime}
 */
@RestController
@RequiredArgsConstructor
@RequestMapping("/${pathName}" )
public class ${className}Controller {
    private final  ${className}Service ${classname}Service;
    /**
     * 分页查询
     * @param page 分页对象
     * @param ${classname} ${comments}
     * @return
     */
    @GetMapping("/page" )
    @PreAuthorize("@pms.hasPermission('${moduleName}_${pathName}_get')" )
    public R get${className}Page(Page page, ${className} ${classname}) {
        return R.ok(${classname}Service.page(page, Wrappers.query(${classname})));
    }
    /**
     * 通过id查询${comments}
     * @param ${pk.lowerAttrName} id
     * @return R
     */
    @GetMapping("/{${pk.lowerAttrName}}" )
    @PreAuthorize("@pms.hasPermission('${moduleName}_${pathName}_get')" )
    public R getById(@PathVariable("${pk.lowerAttrName}" ) ${pk.attrType} ${pk.lowerAttrName}) {
        return R.ok(${classname}Service.getById(${pk.lowerAttrName}));
    }
    /**
     * 新增${comments}
     * @param ${classname} ${comments}
     * @return R
     */
    @SysLog("新增${comments}" )
    @PostMapping
    @PreAuthorize("@pms.hasPermission('${moduleName}_${pathName}_add')" )
    public R save(@RequestBody ${className} ${classname}) {
        // TODO 业务逻辑判断
        return R.ok(${classname}Service.save(${classname}));
    }
    /**
     * 修改${comments}
     * @param ${classname} ${comments}
     * @return R
     */
    @SysLog("修改${comments}" )
    @PutMapping
    @PreAuthorize("@pms.hasPermission('${moduleName}_${pathName}_edit')" )
    public R updateById(@RequestBody ${className} ${classname}) {
        // TODO 业务逻辑判断
        return R.ok(${classname}Service.updateById(${classname}));
    }
    /**
     * 通过id删除${comments}
     * @param ${pk.lowerAttrName} id
     * @return R
     */
    @SysLog("通过id删除${comments}" )
    @DeleteMapping("/{${pk.lowerAttrName}}" )
    @PreAuthorize("@pms.hasPermission('${moduleName}_${pathName}_del')" )
    public R removeById(@PathVariable ${pk.attrType} ${pk.lowerAttrName}) {
        return R.ok(${classname}Service.removeById(${pk.lowerAttrName}));
    }
}
```

### 实现低代码效果的其他方式
1. 开发流程
2. code review
3. 
## Reference
[什么是低代码，到底用不用？](https://www.infoq.cn/article/azghhkh5xxtmrdlc6ffc)
