# 回调、观察者、事件监听、发布订阅
## 问题
1. 回调解决了什么？
	1. [24 深入解读回调机制：把你技能亮出来.md](https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E7%99%BD%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2028%20%E8%AE%B2%EF%BC%88%E5%AE%8C%EF%BC%89/24%20%E6%B7%B1%E5%85%A5%E8%A7%A3%E8%AF%BB%E5%9B%9E%E8%B0%83%E6%9C%BA%E5%88%B6%EF%BC%9A%E6%8A%8A%E4%BD%A0%E6%8A%80%E8%83%BD%E4%BA%AE%E5%87%BA%E6%9D%A5.md)
2. RPC 中的回调是怎么回事？
3. 像调用算法打分服务直接返回，然后等着算法再调用 biz 获取打分结果算不算回调？
	1. 其实是实现了异步
4. 异步实现的几种方式
## 回调
要先有调用，才有调用者和被调用者之间的回调。
==实现==
类 A 的 a () 方法调用类 B 的 b () 方法（这就需要 A 持有 B 引用，成员变量形式），然后 B 的 b () 方法异步或同步执行完后再调用 A 的 c () 方法即 callback 方法。（这就需要 b（) 形参有 A 的引用）。A 为回调者，B 为调用者。核心为回调者把自身（this）传递给调动者。
1. class A实现接口CallBack callback——**背景1**
2. class A中包含一个class B的引用b ——**背景2**
3. class B有一个参数为callback的方法f(CallBack callback) ——**背景3**
4. A的对象a调用B的方法 f(CallBack callback) ——A类调用B类的某个方法 C
5. 然后b就可以在f(CallBack callback)方法中调用A的方法 ——B类调用A类的某个方法D
==模块之间的调用方式==
可以分为[三类](https://www.51cto.com/article/645183.html)：同步调用、异步调用和回调。
+ 同步调用：一种阻塞式调用，调用方要等待对方执行完毕才返回，它是一种单向调用；
+ 异步调用：一种类似消息或事件的机制，不过它的调用方向刚好相反，接口的服务在收到某种讯息或发生某种事件时，会主动通知客户方（即调用客户方的接口）。
+ 回调：一种双向调用模式，被调用方在接口被调用时也会调用对方的接口；

回调和异步调用的关系非常紧密：使用回调来实现异步消息的注册，通过异步调用来实现消息的通知。

==回调与异步的关系==
回调是实现异步调用的一种手段
==回调与观察者模式的关系==
监听器模式的本质就是观察者模式，先将回调函数注册到被观察对象，当被观察对象发生变化时，通过回调函数告知观察者/监听者。
==回调与事件驱动的关系==
事件驱动是思想，回调是其一种实现方式。

##### 总结
个人感觉回调可以实现异步，而异步同步指的是通知方式，所以本质上回调是提供了一种异步调用的结果通知。而事件驱动，是 A 模块事件产生消息后就不再关注，不必等其他模块反应，天然异步高内聚。而其他模块获取消息的方式要么是观察者模式，A 模块遍历观察者集合进行消息通知。或者进一步解耦，发布订阅模式，引入 mq。
![400|600](Pasted%20image%2020230823144029.png)
##### reference
1.  [Java回调机制总结](https://www.cnblogs.com/prayjourney/p/9667835.html)
2.  [JAVA回调机制(CallBack)详解](https://www.cnblogs.com/heshuchao/p/5376298.html)
3. [事件驱动和回调函数之间有何联系？ - 知乎](https://www.zhihu.com/question/30396023)

## 生产者模式

在讨论以下几种模式，都离不开两个因子，一个是消息生产者和消息消费者，一个就是生产者和消费者通信。
其中，后者通过回调实现。但前者，与生产者模式却又不同。感觉生产者模式强调的是消息本身问题，比如速率以及响应式的背压，引入的队列将生产者消费者解耦。而观察者、监听器、发布订阅更侧重的是通信。
感觉上面这个问题，可以在各个设计模式相关性的那个图找到答案。
![400|600](Pasted%20image%2020230824111546.png) 



## 观察者模式
通过回调实现，一个对象状态改变，所有对它依赖的对象都会被通知。
1.  观察者：事件监听器，回调函数接口
2.  目标： 事件源、事件，调用者。注册/撤销观察者（监听器），接收主题对象（事件对象）传递给观察者（监听器），具体由感兴趣的观察者（监听器）执行

## 事件监听
1.  事件监听器： 监听感兴趣事件
2.  事件源：持有监听器成员变量，在自身事件中调用监听器监听方法。
3.  事件： 持有事件源成员变量，为了在监听器内部能通过事件对象获取到事件源对象

监听器即回调函数接口，事件源即调用者

### 监听器模式与观察者模式
监听器模式并不是一个新的设计模式，它是观察者模式在特定场景下的一种改造和应用。通常，观察者模式的主题在通知观察者时，通知中不包含任何信息。如果这个过程中携带了一些其他信息，那么主题本身就成为了事件源，而携带信息的封装类就成为了事件。此时的观察者模式，也就升级为监听器了。监听器模式是观察者模式的另一种形态。
在很多场景中，通知中附带了一些必不可少的其他信息，而事件 Event 可以对这些信息进行封装，使它本身拥有了多态的特性。每个事件对象就可以包含不同的信息。从这个层面来说，事件监听器模式是对观察者模式进行了进一步的抽象。

![](Pasted%20image%2020230202162257.png)

##### refrence
1.  [监听器模式和观察者模式的关系](https://mp.weixin.qq.com/s/DoZgR8td8Zso_rZWEVA4Cw)

## 发布订阅模式
1.  发布者
2.  订阅者
3.  发布订阅中心
与 `观察者模式` 相比，发布订阅核心基于一个中心来建立整个体系。其中 `发布者` 和 `订阅者` **不直接进行通信**

![400|600](Pasted%20image%2020230824110702.png)
##### refrence
1.  [理解【观察者模式】和【发布订阅】的区别](https://juejin.cn/post/6978728619782701087)

## 总结
1. 都是基于回调，回调解决了通信机制问题
2. 最简单的观察者模式，当被观察者发生状态改变，业务调用观察者集合遍历，通过回调通知观察者。
3. 观察者模式可能不会产生消息，仅仅是一个动作或者状态改变，假如这个动作/状态再进一步产生消息或者抽象成事件，就是监听器模式。
4. 这时候还是生产者持有消费者进行通知，引入中间层队列存储消息，把消息生产者与消费者完全解耦，就是发布订阅模式。
##### refrence
1.  [Java中的观察者，监听器，发布订阅模式](https://blog.csdn.net/belongtocode/article/details/103963480)
2.  [SpringBoot事件监听机制及观察者模式/发布订阅模式](https://www.1024sou.com/article/620830.html)
3. [java设计模式-回调、事件监听器、观察者模式 - 青春暮年 - 博客园](https://www.cnblogs.com/AnXinliang/p/9976252.html)



