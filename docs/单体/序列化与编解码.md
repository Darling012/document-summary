# 序列化与编解码

##### 问题
1. 编解码与序列化有什么关系
	1. [序列化和编码有什么区别？](https://www.thinbug.com/q/3784143)
	2. 编解码更宽泛、笼统。序列化时编解码的一个示例。
2. Java 中的编解码与序列化
	1. 
3. 为什么要实现 Serializable 接口，实现后达到了什么效果
4. [字符流和字节流](JavaIO.md)


## 前置知识

##### 字符和文本
[字符编码笔记：ASCII，Unicode 和 UTF-8 - 阮一峰的网络日志](https://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html)
UTF-8 是 Unicode 的实现方式之一
[Java 语言中字符串和文本的区别是什么？ - 知乎](https://www.zhihu.com/question/590750406)
[二进制传输和文本传输-掘金](https://juejin.cn/s/%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BC%A0%E8%BE%93%E5%92%8C%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93)
字符就是单个字符
文本就是字符的集合，形式包括 txt、html、xml 或者是一段字符，都可以叫文本，包含了用哪个字符集编的码。 感觉文本包含了格式，即换行符。
二进制就是二进制。
![](Pasted%20image%2020230831170435.png)

[JSON，base64 和 urlencode 这三种在 HTTP 协议中经常出现的编码方式](https://github.com/bestswifter/blog/blob/master/articles/http-encoding.md)
1. json 是**字符串**的一种描述方式。本质还是字符串就是比 xml 更简洁。
2. 字符串编码是字符->二进制，base 64 是二进制到字符。
	1. 转后的字符串是标准的 ASCII 码。
	2. 解释了为啥会增加三分之一，这个在华佗时发现过。
3. urlencode 是转换为符合 url 规范的**字符串**
##### 文本和二进制传输
[文本文件与二进制文件的编码差别-阿里云开发者社区](https://developer.aliyun.com/article/4031)
1. 文本文件是基于字符编码的文件，比如 ASCII、UNICODE
2. 二进制就是自定义协议

[二进制协议与文本协议 - 血夜之末 - 博客园](https://www.cnblogs.com/Tiancheng-Duan/p/10826905.html)
阐释了一个点就是从网络模型分层看，http 1. x 协议是文本协议，传输 json、xml 等文本文件，最终传输的二进制是下层的。那么参考下边 gpt 的回答，是不是就是 http 的请求头请求体中已经包含了用了什么字符集，所以无论 chrome 还是  [wireshak](https://blog.csdn.net/qq840166422/article/details/116495729)  都可以正常显示。

[二进制编码传输协议](https://segmentfault.com/a/1190000022356844)
[网络传输中文本传输与二进制传输与字符集\_文本传递和字符流\_ccfboy的博客-CSDN博客](https://blog.csdn.net/ccfboy/article/details/6170538)

[`WebSocket可以发送文本，也可发送二进制`是什么意思？](https://segmentfault.com/q/1010000043507256?utm_source=sf-similar-question)
1. 数据传输全是二进制。
2. 得有个地方去标识是文本传输还是二进制
3. 假如是文本，就得知道用的什么字符集

##### http 请求参数在网络中什么样
###### http1.1 基于文本

用 wireshark 抓包，用 `@PathVariable` 和 `@RequestParam` 的参数都是直接拼接的，中文会经过 `urlEncode` 进行编码。
用 `@RequestBody` 传递的参数都是正常显示，包括中文。
所以，[HTTP传输的是字符串，到了TCP层以二进制传输](https://segmentfault.com/q/1010000006670932) ^98766n

[字符流、字节流、二进制及其在HTTP协议传输 - 时间朋友 - 博客园](https://www.cnblogs.com/doit8791/p/7664961.html)
HTTP 请求头和响应头都是以 ASCII 文本方式传输的，但是传输内容（请求响应体）可能是多种形式的。接收方处理数据时是根据请求头/响应头中的 content-type 属性来处理的。
![](Pasted%20image%2020230417154425.png)

###### http2 基于二进制
[使用Wireshark抓取Http2协议报文\_wireshark http2\_Cloud-Future的博客-CSDN博客](https://blog.csdn.net/gybshen/article/details/125376254)




##### 总结
1. 要按网络模型分层看
2. 文本传输相比于二进制传输，因为有了字符集，也可以说是定长编码，二进制是不定长的自定义编码。


## 编解码




![深入分析Java web技术内幕](深入分析Java%20web技术内幕.md#第%203%20章%20深入分析%20Java%20Web%20的中文编码问题)


## 序列化
### Java 序列化
当序列化一个对象到文件时，按照 Java 标准的约定是给文件一个 `.ser` 扩展名。实现 Serializable 接口，jvm 就会把对象按默认格式序列化。

[Java 序列化与主流编解码技术框架介绍 - Java天堂](https://www.javatt.com/p/9376)
1. Java 序列化
	1. Java 序列化只是 Java 编解码的一种。
	2. 基于 Java 提供的对象输入/输出流 ObjectInputStream 和 ObjectOutputStream

[Java序列化和反序列化为什么要实现Serializable接口](https://blog.csdn.net/litianxiang_kaola/article/details/100097019)
==序列化和反序列化==
1. 序列化
	1. 对象-》字节序列
2. 反序列化
	1. 字节序列-》对象
==什么时候需要用到序列化和反序列化呢?==
1. 只要对内存里的数据进行持久化或者网络传输，就需要序列化。
2. http 交互都是 json
	1. json 格式是将对象转为字符串，所以后端与浏览器交互的数据格式是字符串
	2. java String 类型 默认实现了序列化接口，并显式指定了序列化 ID
	3. 此处有误导，采用 json 序列化后跟 Java 就没啥关系了，也就是实际项目必须序列化就是用到 Java 的 ObjectOutputStream 场景。 
		1. spring mvc 在写输入流时用的是什么？没搜到用 ObjectOutputStream。
	4. [java 中Serializable存在的意义是什么？ - 知乎](https://www.zhihu.com/question/283510695)
3. 持久化到数据库
	1. 实际是将对象中的各个属性持久化到数据库
	2. 对象属性都实现了序列化接口，基本类型数据库有对应字段 [ORM类型映射](ORM类型映射.md)
	3. [实体类为什么要实现Serializable接口_username-linyi的博客-CSDN博客](https://blog.csdn.net/jzlinyi/article/details/100657788)
	4. [谈谈序列化—实体bean一定要实现Serializable接口？](https://blog.csdn.net/hhx0626/article/details/61919232)
	5. [浅谈实体类为什么要实现Serializable接口？ - 一中晴哥威武 - 博客园](https://www.cnblogs.com/liuqing576598117/p/9518477.html)
4. [补充总结](https://blog.csdn.net/qq_45464560/article/details/120472154)
	1. 转化为二进制字节流，需要实现序列化接口。存贮 redis。其实还是看选择的序列化方案 [redis序列化](redis客户端及配置.md)
	2. 转化为 json 字符串，不需要。http rpc
==实现序列化和反序列化为什么要实现 Serializable 接口?==
1. java 中实现序列化接口后，jvm 底层自动实现序列化和反序列化
2. 若不实现，就需要自己去写了

==为什么要显示指定 serialVersionUID 的值?==
若不指定
1. jvm 在序列化时会自动生成 serialVersionUID，然后与属性一起序列化后持久化或网络传输。
2. 在反序列化时，jvm 会根据属性再生成一个 serialVersionUID
3. 然后 jvm 会对比着两个，一样则成功，反之失败
若显式指定
1. jvm 反序列化生成的值会是指定的值
实际开发
1. 对象属性会变
2. 若不指定，serialVersionUID 就会变，就会反序列化失败
3. [JDK 序列化时 serialVersionUID 不一致的兼容处理 - 掘金](https://juejin.cn/post/6961229793056686117)

 ==被 transient 关键字修饰的属性不会被序列化, static 属性也不会被序列化==
1. 因为序列化是针对对象而言的, 而 static 属性优先于对象存在, 随着类的加载而加载, 所以不会被序列化
2. 我们定义的时候 serialVersionUID 也是 static 的，为什么跟着序列化了
	1. JVM 在序列化对象时会自动生成一个 serialVersionUID, 然后将我们显示指定的 serialVersionUID 属性值赋给自动生成的 serialVersionUID


[关于序列化的 10 几个问题](https://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&mid=2247494108&idx=3&sn=1914c3152c1a334637cce534ea490cf9)
==什么是 serialVersionUID ？如果你不定义这个, 会发生什么？==
SerialVerionUID 用于对象的版本控制。也可以在类文件中指定 serialVersionUID。不指定 serialVersionUID 的后果是, 当你添加或修改类中的任何字段时, 则已序列化类将无法恢复, 因为为新类和旧序列化对象生成的 serialVersionUID 将有所不同。

[父子类序列及多次序列化问题](https://mp.weixin.qq.com/s/JpcY6NavvlXXbaFFcOw-Jw)
1. 子类实现 Serializable 接口，父类没有实现，子类可以序列化吗？
	1. 可以，但父类要提供空的构造方法
2. 类中存在引用对象，这个类对象在什么情况下可以实现序列化？
	1. 一个类里面所有的属性必须是可序列化的，这个类才能顺利的序列化
3. 同一个对象多次序列化之间有属性更新，前后的序列化有什么区别？
	1. 试图序列化一个对象，会检查这个对象是否已经序列化过，若从未序列化过，才会序列化为字节序列去输出。若已经序列化过，则会输出一个编码符号，不会重复序列化一个对象
4. [我对java中Serializable接口的理解 | DarLie's Home](https://blademastercoder.github.io/2015/01/29/java-Serializable.html)
5. [不实现序列化 (implements serializable) 会怎样？](https://www.codenong.com/cs106066259/)

### json
[Fastjson自定义序列化](https://rstyro.github.io/blog/2021/05/11/Fastjson%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BA%8F%E5%88%97%E5%8C%96/)

### protobuf
#### 为什么说 protobuf 更小更快
[Protobuf为什么这么快？ - Biubiubiu技术分享](http://acodespace.com/archives/protobuf-wei-shen-me-zhe-me-kuai-)
[protobuf为什么那么快 - 简书](https://www.jianshu.com/p/72108f0aefca)

## reference
[Protobuf与Json的相互转化 · DoneSpeak | DoneSpeak' Journal](https://donespeak.gitlab.io/posts/190827-protobuf-json-interconvert/)
[Protobuf 与 JSON 性能对比, Java序列化性能对比, Flatbuffers vs protobuf, Protobuf-java, Protobuf java反序列化, Kryo vs protobuf, Thrift vs Protobuf, Avro 与 Protobuf 基准测试](https://www.zditect.com/article/2677118.html)



