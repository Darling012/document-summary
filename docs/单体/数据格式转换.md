# 数据格式转换

##### 存在格式转换的情况
任意两个组件之间，存在[序列化反序列](序列化与编解码.md)时，就有可能格式不匹配
1. 有可能是组件自身特性，比如 `mysql` 没有 `string` 
2. 也有可能是编程语言差异，比如 `js` 的 `long` 类型溢出
3. 再或者是不同组件、服务之间定义字段的差异。比如 A 服务用的 `String`，B 服务用的 `Integer`。

格式转换**≠**序列化
==两个过程==
1. 入参反序列化
2. 返回值序列化

==不同组件可能是==：
1. 前后端（srping mvc）
2. 后端服务之间 (fegin)
3. 后端与数据库 (jdbc)。

==参数分为两类==：
1. 平铺参数
2. pojo

## 前后端

### springMVC 参数 Convert

#### 日期格式处理
[Feign 日期格式转换错误_black_area的博客-CSDN博客_feign 日期格式](https://blog.csdn.net/hpc_2015/article/details/97897660)

前端请求参数都是字符类型，后端假如是用 `String` 类型接收，就不需要用到类型转换。只有 API 的入参为日期类型才会用到。

##### 平铺参数处理
针对于 `@PathVariable`、`RequestParam`（包括 pojo 形式）起作用。
优先级为 4321
1. @DateTimeFormat
2.  `org.springframework.core.convert.converter.Converter<S,T>` 
	1. 这些 Converter 会注入到 ConversionService 中
3. 自定义 `org.springframework.format.Formatter<T>`
4. 使用 ControllerAdvice 配合 initBinder

##### pojo 参数
1. @JsonFormat
2. 涉及序列化，通过序列化处理，指定序列化和反序列化。
	1. jaskon 序列化 `HttpMessgeConverter`
	2. ObjectMapper（这个玩意儿会注入到 Jackson 的 `HttpMessagConverter ` 里面，即 ` MappingJackson2HttpMessageConverter ` 中）来实现 Json 格式数据的序列化和反序列化

针对于类型为 `LocalDateTime` 的**返回值**都带有"T"拼接符问题，分析如下：
["T"拼接于](https://segmentfault.com/q/1010000002909777) `LocalDateTime#toString()`,所以猜测无论是 log 打印还是序列化都不可避免调用 toString 方法。
所以解决要么更改返回值类型为 `String`，主动调用 `LocalDateTime.format(DateTimeFormatter)`，要么配置
`ObjectMapper(jackson)` 等序列化方案。

其中针对于[平铺参数处理](数据格式转换.md#平铺参数处理)提到的内容，都是调用 `LocalDateTim.parse(text, DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"))`,主要应用于入参类型为日期类型时进行格式转换。

具体参考代码笔记
1. [spring mvc配置格式转换](https://github.com/Darling012/springboot-summary/tree/master/src/main/java/com/learn/mvc/timeCovert)
2.  [LocalDateTime格式转换](https://github.com/Darling012/java-summary/tree/master/java8/src/main/java/com/learn/java8/time)

一个猜测：
API 入参为日期类型，那么会调用配置的 `String=>日期` 的[转换器](数据格式转换.md#平铺参数处理)，既然到方法入口时已经是 String，说明已经完成了反序列化。那么这个反序列化过程是在哪完成的？猜测为 `参数解析器`，那么 `参数解析器` 与 `格式转换器` 是怎么配合的呢？或者说为什么不直接将字节序列转换为日期类型？还是说并没有先转成 String?
debug get 请求  `http://localhost:8080/admin/time/request-param?time=2020-01-01 11:11:11` 
1. 在 `HandlerMethodArgumentResolver#resolveArgument` 中, 解析参数
2. `@PathVariable` 是 `PathVariableMethodArgumentResolver`，用 `Map<String, String> uriTemplateVars` 接收
3. `@RequestParam` 是 `RequestParamMethodArgumentResolver`，用 `String[] paramValues` 接收
4. `@PathVariable` 和 `@RequestParam` 都是转为字符后调用 `binder.convertIfNecessary` 转换类型
5. `@RequestBody` 是在 `RequestResponseBodyMethodProcessor` 中调到 `AbstractMessageConverterMethodArgumentResolver#readWithMessageConverters` 完成参数解析及格式转换。
6. `@RequestBody` 源码解析参考小马哥的 springboot 2.0

##### reference
1. [@JSONFormat，解决时间带T_LC超人在良家的博客-CSDN博客_jsonformat 带t](https://blog.csdn.net/LC_Liangchao/article/details/121907084)
2. [@DateTimeFormat和@JsonFormat](https://mp.weixin.qq.com/s?__biz=Mzg3MjA4MTExMw==&mid=2247487403&idx=2&sn=d3a4b4fd9a05a1b338970828129049b1)
3. [java - Springboot 关于日期时间格式化处理方式总结_个人文章 - SegmentFault 思否](https://segmentfault.com/a/1190000021906586)

## 后端服务之间
figin

## 后端与数据库 
![ORM类型映射](ORM类型映射.md)


[Spring 类型转换](spring核心编程思想.md#第十五章：Spring%20类型转换（Type%20Conversion）%2015%20讲)